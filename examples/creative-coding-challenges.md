# Creative Coding Challenges - Examples

This directory contains example challenges generated by the Creative Coding Challenge Generator.

## Example 1: Pattern Recognition in Code

**Category:** Algorithms  
**Difficulty:** Medium  
**Estimated Time:** 90 minutes

### Challenge

Build an algorithm that identifies repeating patterns in code repositories, inspired by the autonomous AI's pattern matching.

### Requirements

1. Implement a pattern detection algorithm
2. Support multiple programming languages
3. Calculate pattern frequency and relevance
4. Provide pattern extraction and reporting

### Example Input

```python
# Sample code with patterns
def process_data(data):
    if data is None:
        return []
    
    result = []
    for item in data:
        if item.is_valid():
            result.append(item.process())
    return result

def process_items(items):
    if items is None:
        return []
    
    output = []
    for i in items:
        if i.is_valid():
            output.append(i.process())
    return output
```

### Expected Output

```json
{
  "patterns": [
    {
      "type": "null_check_pattern",
      "frequency": 2,
      "locations": ["line 2-3", "line 12-13"],
      "confidence": 0.95
    },
    {
      "type": "list_comprehension_alternative",
      "frequency": 2,
      "locations": ["line 5-8", "line 15-18"],
      "confidence": 0.87
    }
  ]
}
```

### Hints

- Consider using abstract syntax trees (AST) for language-agnostic parsing
- Implement sliding window algorithm for pattern detection
- Use hashing for efficient pattern comparison

---

## Example 2: Functional Code Poetry Generator

**Category:** Creative  
**Difficulty:** Medium  
**Estimated Time:** 120 minutes

### Challenge

Create a system that generates executable code that is also aesthetically pleasing as poetry, inspired by the AI's creative capabilities.

### Example Output (Haiku Style)

```python
# Data flows gently
data = [1, 2, 3, 4, 5]
# Through transform's pathway
result = map(lambda x: x * 2, data)
# Results bloom anew
print(list(result))
```

Output: `[2, 4, 6, 8, 10]`

### Example Output (Sonnet Style)

```python
"""
Shall I compare thee to a sorted list?
Thou art more lovely and more ordinate.
"""

def compare_to_sorted(array):
    """When in eternal lines through code thou grow'st"""
    return sorted(array) == array

# So long as men can breathe or eyes can see,
data = [1, 2, 3, 4, 5]
# So long lives this, and this gives life to thee.
print(compare_to_sorted(data))  # True
```

### Requirements

1. Generate syntactically valid code in target language
2. Code should read like poetry when formatted
3. Maintain functional correctness
4. Support multiple aesthetic styles

---

## Example 3: Self-Documenting API Generator

**Category:** API  
**Difficulty:** Hard  
**Estimated Time:** 150 minutes

### Challenge

Build an API that automatically generates comprehensive documentation from its usage patterns.

### Example Usage

```python
from autodoc_api import AutoDocAPI

# Create API with auto-documentation
api = AutoDocAPI()

@api.route('/users', methods=['GET'])
def get_users(page=1, limit=10):
    """Auto-documented endpoint"""
    return {"users": [...], "page": page, "limit": limit}

# After several API calls, generate documentation
api.start_tracking()

# Simulate usage
api.call('/users?page=1&limit=20')
api.call('/users?page=2&limit=20')
api.call('/users?page=1&limit=50')

# Generate documentation
docs = api.generate_docs()
```

### Expected Documentation Output

```yaml
openapi: 3.0.0
info:
  title: Auto-Generated API
  version: 1.0.0
paths:
  /users:
    get:
      summary: Get users with pagination
      parameters:
        - name: page
          in: query
          schema:
            type: integer
            default: 1
          description: Page number (common values: 1, 2)
        - name: limit
          in: query
          schema:
            type: integer
            default: 10
          description: Results per page (common values: 20, 50)
      responses:
        '200':
          description: Successful response
          content:
            application/json:
              schema:
                type: object
                properties:
                  users:
                    type: array
                  page:
                    type: integer
                  limit:
                    type: integer
              examples:
                common_usage:
                  value: {"users": [...], "page": 1, "limit": 20}
```

### Hints

- Implement middleware to capture API calls
- Use OpenAPI/Swagger for documentation structure
- Analyze request/response patterns for examples

---

## Example 4: Dynamic Knowledge Graph Builder

**Category:** Data Structures  
**Difficulty:** Hard  
**Estimated Time:** 180 minutes

### Challenge

Implement a dynamic knowledge graph that learns relationships between concepts from code and documentation.

### Example Input

```markdown
# Documentation
Repository uses Python for backend.
FastAPI framework handles API endpoints.
PostgreSQL stores user data.
Redis caches frequent queries.
Frontend built with React.
```

```python
# Code
from fastapi import FastAPI
import psycopg2
import redis

app = FastAPI()
db = psycopg2.connect(...)
cache = redis.Redis(...)
```

### Expected Knowledge Graph

```json
{
  "nodes": [
    {"id": "python", "type": "language"},
    {"id": "fastapi", "type": "framework"},
    {"id": "postgresql", "type": "database"},
    {"id": "redis", "type": "cache"},
    {"id": "react", "type": "frontend"}
  ],
  "relationships": [
    {"from": "python", "to": "fastapi", "type": "uses", "weight": 0.95},
    {"from": "fastapi", "to": "postgresql", "type": "stores_in", "weight": 0.88},
    {"from": "fastapi", "to": "redis", "type": "caches_with", "weight": 0.82},
    {"from": "frontend", "to": "react", "type": "built_with", "weight": 0.90}
  ]
}
```

### Query Examples

```python
# Find related concepts
graph.query("What frameworks use Python?")
# Returns: ["FastAPI", ...]

# Find connections
graph.find_path("React", "PostgreSQL")
# Returns: React -> Frontend -> Backend -> FastAPI -> PostgreSQL
```

---

## Example 5: Autonomous Workflow Orchestrator

**Category:** System Design  
**Difficulty:** Expert  
**Estimated Time:** 200 minutes

### Challenge

Design a system that automatically orchestrates workflows based on dependencies and resource availability.

### Example Workflow Definition

```yaml
workflow:
  name: "Data Pipeline"
  tasks:
    - id: extract
      depends_on: []
      resources: {cpu: 2, memory: 4GB}
      duration: 10min
    
    - id: transform
      depends_on: [extract]
      resources: {cpu: 4, memory: 8GB}
      duration: 30min
    
    - id: validate
      depends_on: [transform]
      resources: {cpu: 1, memory: 2GB}
      duration: 5min
    
    - id: load
      depends_on: [validate]
      resources: {cpu: 2, memory: 4GB}
      duration: 15min
    
    - id: notify
      depends_on: [load]
      resources: {cpu: 1, memory: 1GB}
      duration: 1min

resources:
  available: {cpu: 8, memory: 16GB}
```

### Expected Execution Plan

```json
{
  "execution_plan": [
    {
      "wave": 1,
      "tasks": ["extract"],
      "start_time": "00:00",
      "resources_used": {"cpu": 2, "memory": "4GB"}
    },
    {
      "wave": 2,
      "tasks": ["transform"],
      "start_time": "00:10",
      "resources_used": {"cpu": 4, "memory": "8GB"}
    },
    {
      "wave": 3,
      "tasks": ["validate"],
      "start_time": "00:40",
      "resources_used": {"cpu": 1, "memory": "2GB"}
    },
    {
      "wave": 4,
      "tasks": ["load"],
      "start_time": "00:45",
      "resources_used": {"cpu": 2, "memory": "4GB"}
    },
    {
      "wave": 5,
      "tasks": ["notify"],
      "start_time": "01:00",
      "resources_used": {"cpu": 1, "memory": "1GB"}
    }
  ],
  "total_time": "61 minutes",
  "max_parallelism": 1,
  "resource_efficiency": 0.65
}
```

### Hints

- Use directed acyclic graphs (DAG) for dependencies
- Implement topological sorting for execution order
- Consider priority queues for scheduling
- Add circuit breakers for fault tolerance

---

## How to Submit Solutions

1. **Fork the repository**
2. **Create a solution branch**: `git checkout -b solution/challenge-id/your-name`
3. **Implement your solution** in `solutions/challenge-id/`
4. **Add tests** in `solutions/challenge-id/tests/`
5. **Create PR** with tag `coding-challenge` and challenge ID
6. **Wait for review** from the community

## Evaluation Criteria

Solutions are evaluated on:

- âœ… **Correctness**: Passes all test cases
- ðŸŽ¯ **Code Quality**: Clean, readable, well-documented
- âš¡ **Performance**: Efficient implementation
- ðŸŽ¨ **Creativity**: Innovative approaches

## Resources

- [Generator Documentation](../docs/creative-coding-challenge-generator.md)
- [Learnings Book](../learnings/book) - Technical insights
- [Community Solutions](../solutions) - Past challenge solutions

---

*ðŸ¤– Examples generated by Creative Coding Challenge Generator (@create-guru)*
