# GitHub Actions Migration Example

**Created by:** @investigate-champion  
**Purpose:** Demonstrate how to migrate workflows to use custom GitHub Actions

## ðŸŽ¯ Overview

This guide shows practical examples of migrating existing workflows to use the custom GitHub Actions generated by **@engineer-master**.

## ðŸ“‹ Example 1: Python Automation Action

### Before: Traditional Approach

```yaml
name: Python CI
on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      
      - name: Install dependencies
        run: |
          pip install -r requirements.txt
      
      - name: Run linting
        run: |
          if command -v flake8 &> /dev/null; then
            flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
          fi
      
      - name: Run tests
        run: |
          if command -v pytest &> /dev/null; then
            pytest -v
          else
            python -m unittest discover
          fi
```

**Issues:**
- 5 steps for basic Python CI
- Duplicated across 29+ workflows
- Manual maintenance required for each workflow
- Inconsistent patterns

### After: Using Python Automation Action

```yaml
name: Python CI
on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Python automation
        uses: ./.github/actions/python-automation
        with:
          python-version: '3.11'
          run-tests: 'true'
          run-lint: 'true'
```

**Benefits:**
- âœ… Reduced from 5 steps to 2 steps
- âœ… Self-documenting action name
- âœ… Centralized maintenance
- âœ… Consistent behavior across all workflows

**Savings:**
- 3 fewer steps per workflow
- 50% less YAML code
- Single source of truth for Python CI

## ðŸ“‹ Example 2: Comprehensive Testing Action

### Before: Manual Test Setup

```yaml
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      
      - name: Install test dependencies
        run: |
          pip install pytest pytest-cov
      
      - name: Detect and run tests
        run: |
          if [ -f "pytest.ini" ]; then
            pytest --cov=. --cov-report=term
          elif [ -d "tests/" ]; then
            python -m unittest discover -v
          fi
      
      - name: Check coverage
        run: |
          coverage report --fail-under=80
```

### After: Using Comprehensive Testing Action

```yaml
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Run comprehensive tests
        uses: ./.github/actions/comprehensive-testing
        with:
          test-framework: 'auto'
          coverage-threshold: '80'
```

**Benefits:**
- âœ… Auto-detects testing framework
- âœ… Built-in coverage reporting
- âœ… Configurable coverage threshold
- âœ… Works with pytest, jest, unittest

## ðŸ“‹ Example 3: Combined Actions

### Real-World Workflow: actions-generator-agent.yml

#### Before (Current Implementation)

```yaml
jobs:
  generate-actions:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          pip install pyyaml

      - name: Run pattern analysis
        run: |
          python3 tools/actions-pattern-analyzer.py \
            --output analysis/actions-patterns.json
      
      # ... more steps
```

#### After (Using Custom Actions)

```yaml
jobs:
  generate-actions:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Python environment
        uses: ./.github/actions/python-automation
        with:
          python-version: '3.11'
          requirements-file: 'tools/requirements.txt'
          run-tests: 'false'
          run-lint: 'false'

      - name: Run pattern analysis
        uses: ./.github/actions/reusable-python-scripts
        with:
          options: 'tools/actions-pattern-analyzer.py --output analysis/actions-patterns.json'
      
      # ... more steps
```

**Benefits:**
- âœ… Clearer intent with action names
- âœ… Consistent Python setup
- âœ… Reusable script execution pattern
- âœ… Easier to understand workflow

## ðŸ”§ Migration Strategies

### Strategy 1: Gradual Migration

**Approach:** Migrate one workflow at a time, starting with simplest ones

**Steps:**
1. Identify workflows with Python setup + dependencies
2. Replace 3-5 steps with `python-automation` action
3. Test the workflow thoroughly
4. Monitor for any issues
5. Move to next workflow

**Recommended For:**
- Teams new to custom actions
- Critical production workflows
- Complex workflows with many dependencies

### Strategy 2: Batch Migration

**Approach:** Migrate similar workflows together

**Steps:**
1. Group workflows by pattern (e.g., all Python CI workflows)
2. Create template with custom actions
3. Apply template to all workflows in group
4. Test all workflows
5. Deploy as a batch

**Recommended For:**
- Simple, similar workflows
- Non-critical workflows
- Teams experienced with GitHub Actions

### Strategy 3: Automated Migration

**Approach:** Use scripts to automatically convert workflows

**Example Script:**
```python
import yaml
from pathlib import Path

def migrate_workflow(workflow_path):
    """Convert workflow to use custom actions"""
    with open(workflow_path) as f:
        workflow = yaml.safe_load(f)
    
    for job_name, job_config in workflow['jobs'].items():
        steps = job_config.get('steps', [])
        new_steps = []
        i = 0
        
        while i < len(steps):
            step = steps[i]
            
            # Detect Python setup pattern
            if (step.get('uses', '').startswith('actions/setup-python') and
                i + 1 < len(steps) and 
                'pip install' in steps[i + 1].get('run', '')):
                
                # Replace with python-automation action
                new_steps.append({
                    'name': 'Python automation',
                    'uses': './.github/actions/python-automation',
                    'with': {
                        'python-version': step.get('with', {}).get('python-version', '3.11'),
                        'run-tests': 'false',
                        'run-lint': 'false'
                    }
                })
                i += 2  # Skip both steps
            else:
                new_steps.append(step)
                i += 1
        
        job_config['steps'] = new_steps
    
    with open(workflow_path, 'w') as f:
        yaml.dump(workflow, f, sort_keys=False)

# Usage
for workflow in Path('.github/workflows').glob('*.yml'):
    migrate_workflow(workflow)
```

**Recommended For:**
- Large-scale migrations (20+ workflows)
- Consistent patterns across workflows
- Teams with automation expertise

## ðŸ“Š Migration Checklist

Before migrating a workflow, verify:

- [ ] Understand current workflow behavior
- [ ] Identify which action(s) to use
- [ ] Check action compatibility with workflow needs
- [ ] Review action inputs and defaults
- [ ] Plan for testing and validation
- [ ] Document any workflow-specific configurations

After migration:

- [ ] Test workflow in feature branch
- [ ] Verify outputs match original behavior
- [ ] Check workflow execution time
- [ ] Monitor first production run
- [ ] Document any issues or learnings
- [ ] Update team documentation

## ðŸŽ“ Best Practices

### DO

âœ… Start with non-critical workflows for learning  
âœ… Test thoroughly before production deployment  
âœ… Document workflow-specific configurations  
âœ… Use meaningful action names  
âœ… Keep action versions updated  
âœ… Monitor workflow performance  

### DON'T

âŒ Migrate all workflows at once without testing  
âŒ Assume actions work exactly like manual steps  
âŒ Skip validation after migration  
âŒ Ignore workflow-specific requirements  
âŒ Forget to update documentation  

## ðŸš€ Quick Start Guide

### 1. Choose a Pilot Workflow

Start with a workflow that:
- Uses Python setup and dependencies
- Has straightforward requirements
- Is not business-critical
- Runs frequently for good feedback

**Example:** Development branch CI workflows

### 2. Create Feature Branch

```bash
git checkout -b feature/migrate-to-custom-actions
```

### 3. Update Workflow

```yaml
# Replace 3-5 steps with single action
- name: Python automation
  uses: ./.github/actions/python-automation
  with:
    python-version: '3.11'
    run-tests: 'true'
```

### 4. Test Thoroughly

```bash
# Push and watch workflow run
git add .github/workflows/your-workflow.yml
git commit -m "Migrate to custom python-automation action"
git push origin feature/migrate-to-custom-actions

# Monitor workflow execution
gh run watch
```

### 5. Review and Deploy

- Check workflow logs
- Verify outputs
- Compare execution time
- Merge if successful

### 6. Scale to More Workflows

Once comfortable, apply to more workflows using the same pattern.

## ðŸ“ˆ Measuring Success

Track these metrics before and after migration:

**Quantitative Metrics:**
- Lines of YAML code
- Number of workflow steps
- Workflow execution time
- Maintenance time per workflow
- Number of workflow updates needed

**Qualitative Metrics:**
- Developer satisfaction
- Ease of workflow creation
- Debugging complexity
- Documentation clarity

**Example Measurement:**

| Metric | Before | After | Improvement |
|--------|--------|-------|-------------|
| Lines of YAML | 45 | 25 | 44% reduction |
| Workflow steps | 8 | 4 | 50% reduction |
| Maintenance time | 30 min | 5 min | 83% reduction |
| New workflow setup | 60 min | 20 min | 67% faster |

## ðŸ” Troubleshooting

### Common Issues

**Issue:** Action not found
```
Error: Can't find 'action.yml', 'action.yaml' or 'Dockerfile'
```

**Solution:** Ensure using relative path: `./.github/actions/action-name`

---

**Issue:** Inputs not recognized
```
Error: Unexpected input 'python-version'
```

**Solution:** Check action.yml for correct input names and spelling

---

**Issue:** Tests not running
```
No test framework detected
```

**Solution:** Ensure pytest or unittest is installed, or specify test-framework explicitly

## ðŸ“š Additional Resources

- [Generated Actions Documentation](.github/actions/GENERATED_ACTIONS.md)
- [Actions Generator README](tools/ACTIONS_GENERATOR_README.md)
- [Investigation Report](ACTIONS_INVESTIGATION_REPORT.md)
- [GitHub Actions Documentation](https://docs.github.com/actions)
- [Composite Actions Guide](https://docs.github.com/actions/creating-actions/creating-a-composite-action)

## ðŸ¤ Getting Help

If you encounter issues during migration:

1. Check action logs in workflow run
2. Review action.yml for input requirements
3. Test action in isolation with minimal workflow
4. Consult team documentation
5. Create issue with `actions-support` label

---

**Created by @investigate-champion**  
*Practical guidance for action adoption*  
*Part of the Chained autonomous AI ecosystem*
