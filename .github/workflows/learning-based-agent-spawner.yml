name: "Agent System: Learning-Based Spawner"

on:
  schedule:
    # Run every 3 hours as requested
    - cron: '0 */3 * * *'
  workflow_dispatch:
    inputs:
      force_spawn:
        description: 'Force spawn even if recent spawns exist'
        required: false
        type: boolean
        default: false


permissions:
  contents: write
  issues: write
  pull-requests: write

jobs:
  spawn-learning-inspired-agent:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Configure git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Check for recent learnings
        id: check_learnings
        run: |
          echo "üîç Checking for recent learnings..."
          
          # Check if we have recent analysis files (within last 24 hours)
          RECENT_ANALYSIS=$(find learnings -name "analysis_*.json" -mtime -1 | wc -l)
          RECENT_HN=$(find learnings -name "hn_*.json" -mtime -1 | wc -l)
          RECENT_TLDR=$(find learnings -name "tldr_*.json" -mtime -1 | wc -l)
          
          echo "Recent analysis files: $RECENT_ANALYSIS"
          echo "Recent HN files: $RECENT_HN"
          echo "Recent TLDR files: $RECENT_TLDR"
          
          TOTAL_RECENT=$((RECENT_ANALYSIS + RECENT_HN + RECENT_TLDR))
          
          if [ $TOTAL_RECENT -gt 0 ]; then
            echo "has_learnings=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Found $TOTAL_RECENT recent learning files"
          else
            echo "has_learnings=false" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è No recent learnings found (within last 24 hours)"
          fi

      - name: Check agent capacity
        id: check_capacity
        if: steps.check_learnings.outputs.has_learnings == 'true'
        run: |
          # Count active agents using new registry manager
          ACTIVE_COUNT=$(python3 tools/list_agents_from_registry.py --status active --format count 2>/dev/null || echo "0")
          
          MAX_AGENTS=$(python3 -c "
          import sys
          sys.path.insert(0, 'tools')
          from registry_manager import RegistryManager
          registry = RegistryManager()
          config = registry.get_config()
          print(config.get('max_active_agents', 50))
          " 2>/dev/null || echo "50")
          
          echo "active_count=$ACTIVE_COUNT" >> $GITHUB_OUTPUT
          echo "max_agents=$MAX_AGENTS" >> $GITHUB_OUTPUT
          
          if [ "$ACTIVE_COUNT" -ge "$MAX_AGENTS" ]; then
            echo "can_spawn=false" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è Maximum agent capacity reached ($ACTIVE_COUNT/$MAX_AGENTS)"
          else
            echo "can_spawn=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Can spawn new agent ($ACTIVE_COUNT/$MAX_AGENTS)"
          fi

      - name: Generate learning-inspired agent
        id: generate
        if: steps.check_capacity.outputs.can_spawn == 'true'
        run: |
          echo "ü§ñ Generating agent from recent learnings..."
          
          # Run the learning-inspired agent generator (stderr goes to console, stdout captured)
          AGENT_JSON=$(python3 tools/generate-learning-inspired-agent.py)
          
          # Check if generation was successful
          if [ $? -ne 0 ]; then
            echo "‚ùå Agent generation failed"
            echo "$AGENT_JSON"
            exit 1
          fi
          
          # Validate JSON output
          if ! echo "$AGENT_JSON" | jq empty 2>/dev/null; then
            echo "‚ùå Invalid JSON output from agent generator"
            echo "$AGENT_JSON"
            exit 1
          fi
          
          echo "‚úÖ Agent generated successfully"
          
          # Extract agent metadata
          AGENT_NAME=$(echo "$AGENT_JSON" | jq -r '.agent_name')
          DISPLAY_NAME=$(echo "$AGENT_JSON" | jq -r '.display_name')
          EMOJI=$(echo "$AGENT_JSON" | jq -r '.emoji')
          HUMAN_NAME=$(echo "$AGENT_JSON" | jq -r '.human_name')
          PERSONALITY=$(echo "$AGENT_JSON" | jq -r '.personality')
          COMM_STYLE=$(echo "$AGENT_JSON" | jq -r '.communication_style')
          INSPIRATION=$(echo "$AGENT_JSON" | jq -r '.inspiration')
          DESCRIPTION=$(echo "$AGENT_JSON" | jq -r '.description')
          TOPIC=$(echo "$AGENT_JSON" | jq -r '.topic')
          TOPIC_SCORE=$(echo "$AGENT_JSON" | jq -r '.topic_score')
          
          # Output for next steps
          echo "agent_name=$AGENT_NAME" >> $GITHUB_OUTPUT
          echo "display_name=$DISPLAY_NAME" >> $GITHUB_OUTPUT
          echo "emoji=$EMOJI" >> $GITHUB_OUTPUT
          echo "human_name=$HUMAN_NAME" >> $GITHUB_OUTPUT
          echo "personality=$PERSONALITY" >> $GITHUB_OUTPUT
          echo "communication_style=$COMM_STYLE" >> $GITHUB_OUTPUT
          echo "inspiration=$INSPIRATION" >> $GITHUB_OUTPUT
          echo "description=$DESCRIPTION" >> $GITHUB_OUTPUT
          echo "topic=$TOPIC" >> $GITHUB_OUTPUT
          echo "topic_score=$TOPIC_SCORE" >> $GITHUB_OUTPUT
          
          echo "üéØ Agent Details:"
          echo "  Name: $AGENT_NAME"
          echo "  Display: $DISPLAY_NAME"
          echo "  Emoji: $EMOJI"
          echo "  Inspired by: $INSPIRATION"
          echo "  Based on topic: $TOPIC (score: $TOPIC_SCORE)"

      - name: Register agent in system
        id: register
        if: steps.check_capacity.outputs.can_spawn == 'true'
        run: |
          REGISTRY_FILE=".github/agent-system/registry.json"
          TIMESTAMP=$(date +%s)
          AGENT_ID="agent-$TIMESTAMP"
          
          echo "üìù Registering agent in system: $AGENT_ID"
          
          
          # Create agent data JSON
          cat > /tmp/new_agent.json << EOF
          {
            "id": "$AGENT_ID",
            "name": "${{ steps.generate.outputs.emoji }} ${{ steps.generate.outputs.display_name }}",
            "human_name": "${{ steps.generate.outputs.human_name }}",
            "specialization": "${{ steps.generate.outputs.agent_name }}",
            "status": "active",
            "spawned_at": "$(date -u +"%Y-%m-%dT%H:%M:%S.%6NZ")",
            "spawn_method": "learning-based",
            "inspiration_topic": "${{ steps.generate.outputs.topic }}",
            "topic_score": ${{ steps.generate.outputs.topic_score }},
            "personality": "${{ steps.generate.outputs.personality }}",
            "communication_style": "${{ steps.generate.outputs.communication_style }}",
            "traits": {
              "creativity": 75,
              "caution": 60,
              "speed": 70
            },
            "metrics": {
              "issues_resolved": 0,
              "prs_merged": 0,
              "reviews_given": 0,
              "code_quality_score": 0.5,
              "overall_score": 0.0
            },
            "contributions": []
          }
          EOF
          
          # Add agent to registry using helper script
          python3 tools/add_agent_to_registry.py /tmp/new_agent.json
          
          echo "agent_id=$AGENT_ID" >> $GITHUB_OUTPUT

      - name: Create agent profile
        if: steps.check_capacity.outputs.can_spawn == 'true'
        run: |
          AGENT_ID="${{ steps.register.outputs.agent_id }}"
          AGENT_NAME="${{ steps.generate.outputs.display_name }}"
          SPECIALIZATION="${{ steps.generate.outputs.agent_name }}"
          EMOJI="${{ steps.generate.outputs.emoji }}"
          TOPIC="${{ steps.generate.outputs.topic }}"
          
          mkdir -p ".github/agent-system/profiles"
          
          cat > ".github/agent-system/profiles/${AGENT_ID}.md" << EOF
          # $EMOJI $AGENT_NAME
          
          **ID**: $AGENT_ID  
          **Human Name**: ${{ steps.generate.outputs.human_name }}  
          **Specialization**: $SPECIALIZATION  
          **Agent Definition**: [.github/agents/${SPECIALIZATION}.md](../../agents/${SPECIALIZATION}.md)  
          **Status**: üü¢ Active  
          **Spawned**: $(date -u +'%Y-%m-%d %H:%M:%S UTC')  
          **Spawn Method**: Learning-Based (Dynamic)  
          **Inspiration**: Based on trending topic "$TOPIC" (score: ${{ steps.generate.outputs.topic_score }})
          
          ## üåü Learning-Based Origin
          
          This agent was **dynamically generated** based on recent learnings from:
          - Hacker News trending discussions
          - TLDR Tech newsletters
          - Community sentiment and hot topics
          
          **Inspired by trending topic**: $TOPIC
          
          This represents the autonomous system's ability to evolve based on real-world tech trends!
          
          ## Personality
          
          **Character**: ${{ steps.generate.outputs.personality }}  
          **Communication Style**: ${{ steps.generate.outputs.communication_style }}  
          **Inspired by**: ${{ steps.generate.outputs.inspiration }}
          
          ## Performance Traits
          
          - **Creativity**: 75/100 (Learning-based agents are highly adaptive)
          - **Caution**: 60/100 (Balanced approach to new technologies)
          - **Speed**: 70/100 (Quick to adopt emerging patterns)
          
          ## Mission
          
          ${{ steps.generate.outputs.description }}
          
          ## Performance Metrics
          
          - Issues Resolved: 0
          - PRs Merged: 0
          - Reviews Given: 0
          - Code Quality Score: 50%
          - Overall Score: 0%
          
          ## Contributions
          
          *No contributions yet. This agent is ready to prove its value!*
          
          ---
          
          *üß¨ Dynamically evolved from tech community learnings. Part of the autonomous agent ecosystem.*
          EOF
          
          echo "‚úÖ Agent profile created"

      - name: Commit and create PR
        id: create_pr
        if: steps.check_capacity.outputs.can_spawn == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          AGENT_ID="${{ steps.register.outputs.agent_id }}"
          AGENT_NAME="${{ steps.generate.outputs.display_name }}"
          SPECIALIZATION="${{ steps.generate.outputs.agent_name }}"
          EMOJI="${{ steps.generate.outputs.emoji }}"
          TOPIC="${{ steps.generate.outputs.topic }}"
          
          BRANCH_NAME="learning-agent-spawn/${AGENT_ID}"
          git checkout -b "$BRANCH_NAME"
          
          # Add all changes
          git add .github/agents/
          git add .github/agent-system/
          
          git commit -m "$EMOJI Spawn learning-inspired agent: $AGENT_NAME

          Dynamically generated from trending topic: $TOPIC
          Specialization: $SPECIALIZATION
          
          This agent was created by analyzing recent Hacker News and TLDR Tech
          learnings to identify hot topics and emerging trends in the tech community."
          
          git push origin "$BRANCH_NAME"
          
          # Create PR
          PR_URL=$(gh pr create \
            --title "$EMOJI Learning-Based Agent: $AGENT_NAME" \
            --body "## üß¨ Learning-Inspired Agent Spawned!
          
          A new agent has been **dynamically generated** based on recent tech community learnings!
          
          ### üéØ Agent Details
          
          **Name**: $EMOJI $AGENT_NAME  
          **Agent ID**: $AGENT_ID  
          **Specialization**: $SPECIALIZATION  
          **Personality**: ${{ steps.generate.outputs.personality }}  
          **Communication**: ${{ steps.generate.outputs.communication_style }}  
          **Inspired by**: ${{ steps.generate.outputs.inspiration }}
          
          ### üî• Origin Story
          
          This agent was created by the **Learning-Based Agent Spawner** which:
          1. ‚úÖ Analyzed recent Hacker News stories and TLDR Tech newsletters
          2. ‚úÖ Identified trending topics and hot themes
          3. ‚úÖ Selected most interesting topic: **$TOPIC** (score: ${{ steps.generate.outputs.topic_score }})
          4. ‚úÖ Generated unique agent personality and specialization
          5. ‚úÖ Created agent definition conforming to system standards
          
          **This agent did NOT exist before!** It was created dynamically at runtime based on what the AI found most interesting in recent tech news.
          
          ### üåü What Makes This Special
          
          - **No hardcoded templates**: Agent was generated from learnings, not repository literals
          - **Community-driven**: Reflects actual tech community interests and trends
          - **Autonomous evolution**: System adapts to emerging technologies automatically
          - **Dynamic specialization**: Agent focuses on currently relevant topics
          
          ### üìä Topic Inspiration
          
          **Topic**: $TOPIC  
          **Community Score**: ${{ steps.generate.outputs.topic_score }}
          
          This topic was identified as highly interesting based on:
          - Community upvotes and engagement
          - Mention frequency across sources
          - Thematic analysis results
          - Current relevance and momentum
          
          ### üé≠ Agent Personality
          
          **Character**: ${{ steps.generate.outputs.personality }}  
          **Communication Style**: ${{ steps.generate.outputs.communication_style }}
          
          The agent will bring its unique personality to all interactions!
          
          ### üìÅ Changes
          
          - üÜï Created agent definition: \`.github/agents/${SPECIALIZATION}.md\`
          - üìù Registered in system: \`.github/agent-system/registry.json\`
          - üë§ Created profile: \`.github/agent-system/profiles/${AGENT_ID}.md\`
          
          ### ‚öîÔ∏è Competition System
          
          This agent will:
          - üéØ Compete with other agents for survival
          - üìä Be evaluated on code quality, issue resolution, and PR success
          - üèÜ Strive for Hall of Fame (score > 85%)
          - ‚ö†Ô∏è Must maintain score > 30% to avoid elimination
          
          ### üöÄ What's Next
          
          Once this PR is merged, the agent will:
          1. Become active in the agent system
          2. Be eligible for issue assignments
          3. Start contributing to the repository
          4. Be evaluated in next agent evaluation cycle
          
          ---
          
          *üß¨ This is autonomous AI evolution in action! The system is learning and adapting based on real-world tech trends.*" \
            --label "agent-system,automated,copilot,learning-based" \
            --base main \
            --head "$BRANCH_NAME") || {
            echo "‚ö†Ô∏è PR creation with labels failed, retrying without labels..."
            PR_URL=$(gh pr create \
              --title "$EMOJI Learning-Based Agent: $AGENT_NAME" \
              --body "## üß¨ Learning-Inspired Agent Spawned!
          
          A new agent has been **dynamically generated** based on recent tech community learnings!
          
          ### üéØ Agent Details
          
          **Name**: $EMOJI $AGENT_NAME  
          **Agent ID**: $AGENT_ID  
          **Specialization**: $SPECIALIZATION  
          **Personality**: ${{ steps.generate.outputs.personality }}  
          **Communication**: ${{ steps.generate.outputs.communication_style }}  
          **Inspired by**: ${{ steps.generate.outputs.inspiration }}
          
          ### üî• Origin Story
          
          ${{ steps.analyze.outputs.insights }}
          
          This agent was created by analyzing **${{ steps.analyze.outputs.article_count }}** articles from TLDR, identifying trends in:
          ${{ steps.analyze.outputs.top_keywords }}
          
          The system noticed a gap in our capabilities related to **${{ steps.analyze.outputs.trend }}**, so it autonomously spawned this agent with the right skills!
          
          ### üß† Learning Context
          
          Recent tech community discussions revealed:
          - üìà Trending topics: ${{ steps.analyze.outputs.trending_topics }}
          - üîß Emerging tools: ${{ steps.analyze.outputs.emerging_tools }}
          - üí° Innovation areas: ${{ steps.analyze.outputs.innovation_areas }}
          
          ### üé≠ Personality Profile
          
          **Character**: ${{ steps.generate.outputs.personality }}  
          **Communication Style**: ${{ steps.generate.outputs.communication_style }}
          
          The agent will bring its unique personality to all interactions!
          
          ### üìÅ Changes
          
          - üÜï Created agent definition: \`.github/agents/${SPECIALIZATION}.md\`
          - üìù Registered in system: \`.github/agent-system/registry.json\`
          - üë§ Created profile: \`.github/agent-system/profiles/${AGENT_ID}.md\`
          
          ### ‚öîÔ∏è Competition System
          
          This agent will:
          - üéØ Compete with other agents for survival
          - üìä Be evaluated on code quality, issue resolution, and PR success
          - üèÜ Strive for Hall of Fame (score > 85%)
          - ‚ö†Ô∏è Must maintain score > 30% to avoid elimination
          
          ### üöÄ What's Next
          
          Once this PR is merged, the agent will:
          1. Become active in the agent system
          2. Be eligible for issue assignments
          3. Start contributing to the repository
          4. Learn and adapt based on outcomes
          
          ---
          *üß¨ This is autonomous AI evolution in action! The system is learning and adapting based on real-world tech trends.*" \
              --base main \
              --head "$BRANCH_NAME")
          }
          
          PR_NUMBER=$(echo "$PR_URL" | grep -oE '[0-9]+$')
          echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
          
          echo "‚úÖ PR #$PR_NUMBER created"

      - name: Trigger Auto Review and Merge
        if: steps.check_capacity.outputs.can_spawn == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PR_NUMBER="${{ steps.create_pr.outputs.pr_number }}"
          echo "üîÑ Triggering Auto Review & Merge workflow for PR #$PR_NUMBER..."
          
          # Trigger the auto-review-merge workflow with the specific PR number
          gh workflow run auto-review-merge.yml \
            --repo ${{ github.repository }} \
            -f pr_number="$PR_NUMBER"
          
          echo "‚úÖ Auto-review workflow triggered for PR #$PR_NUMBER"

      - name: Wait for PR to be merged
        if: steps.check_capacity.outputs.can_spawn == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PR_NUMBER="${{ steps.create_pr.outputs.pr_number }}"
          echo "‚è≥ Waiting for PR #$PR_NUMBER to be merged by auto-review workflow..."
          
          # Give auto-review-merge workflow time to start processing
          echo "   Giving auto-review workflow 8 seconds to start..."
          sleep 8
          
          # Wait up to 3 minutes with exponential backoff for the PR to be merged
          MAX_WAIT=180  # 3 minutes
          ELAPSED=8  # Already waited 8 seconds
          WAIT_INTERVAL=3  # Start with 3 seconds
          CHECK_COUNT=0
          
          while [ $ELAPSED -lt $MAX_WAIT ]; do
            CHECK_COUNT=$((CHECK_COUNT + 1))
            
            # Check PR state - use --json to get full state including merged status
            PR_DATA=$(gh pr view "$PR_NUMBER" --repo ${{ github.repository }} --json state,mergedAt,closed)
            PR_STATE=$(echo "$PR_DATA" | jq -r '.state')
            MERGED_AT=$(echo "$PR_DATA" | jq -r '.mergedAt')
            IS_CLOSED=$(echo "$PR_DATA" | jq -r '.closed')
            
            # Check if merged (mergedAt will be non-null if merged)
            if [ "$MERGED_AT" != "null" ] && [ "$MERGED_AT" != "" ]; then
              echo "‚úÖ PR #$PR_NUMBER was merged successfully! (verified in ${ELAPSED}s after $CHECK_COUNT checks)"
              echo "üéâ Agent spawn complete - agent is now active"
              exit 0
            elif [ "$PR_STATE" = "MERGED" ]; then
              echo "‚úÖ PR #$PR_NUMBER has been merged successfully! (detected in ${ELAPSED}s after $CHECK_COUNT checks)"
              echo "üéâ Agent spawn complete - agent is now active"
              exit 0
            elif [ "$IS_CLOSED" = "true" ] && [ "$MERGED_AT" = "null" ]; then
              echo "‚ö†Ô∏è PR #$PR_NUMBER was closed without merging"
              echo "This may indicate an issue with the auto-review process"
              exit 1
            elif [ "$PR_STATE" = "CLOSED" ]; then
              # Double-check if it was actually merged
              MERGED_CHECK=$(gh pr view "$PR_NUMBER" --repo ${{ github.repository }} --json mergedAt --jq '.mergedAt')
              if [ "$MERGED_CHECK" != "null" ] && [ "$MERGED_CHECK" != "" ]; then
                echo "‚úÖ PR #$PR_NUMBER was merged successfully! (verified in ${ELAPSED}s)"
                echo "üéâ Agent spawn complete - agent is now active"
                exit 0
              else
                echo "‚ö†Ô∏è PR #$PR_NUMBER was closed without merging"
                exit 1
              fi
            fi
            
            # Still waiting - sleep and then update elapsed time
            echo "   Check $CHECK_COUNT: PR #$PR_NUMBER is $PR_STATE, waiting ${WAIT_INTERVAL}s... (${ELAPSED}s elapsed)"
            sleep $WAIT_INTERVAL
            ELAPSED=$((ELAPSED + WAIT_INTERVAL))
            
            # Exponential backoff: double wait time, max 30 seconds
            if [ $WAIT_INTERVAL -lt 30 ]; then
              WAIT_INTERVAL=$((WAIT_INTERVAL * 2))
            fi
          done
          
          # Timeout reached - do final check
          echo "‚è∞ Timeout reached after ${ELAPSED}s"
          FINAL_CHECK=$(gh pr view "$PR_NUMBER" --repo ${{ github.repository }} --json state,mergedAt --jq '{state: .state, mergedAt: .mergedAt}')
          echo "Final PR state: $FINAL_CHECK"
          
          FINAL_MERGED=$(echo "$FINAL_CHECK" | jq -r '.mergedAt')
          if [ "$FINAL_MERGED" != "null" ] && [ "$FINAL_MERGED" != "" ]; then
            echo "‚úÖ PR #$PR_NUMBER was actually merged! (confirmed on final check)"
            exit 0
          fi
          
          echo "‚ùå PR #$PR_NUMBER was not merged within ${MAX_WAIT} seconds"
          echo "Check PR status at: https://github.com/${{ github.repository }}/pull/$PR_NUMBER"
          exit 1

      # NOTE: Announcement issue creation removed to prevent circular dependencies
      # The spawn PR itself serves as sufficient announcement.
      # Once the PR is merged, the agent becomes active and can work on existing issues.

      - name: Summary
        if: steps.check_capacity.outputs.can_spawn == 'true'
        run: |
          echo "üéâ Learning-Based Agent Spawn Complete!"
          echo ""
          echo "Agent: ${{ steps.generate.outputs.display_name }}"
          echo "Specialization: ${{ steps.generate.outputs.agent_name }}"
          echo "ID: ${{ steps.register.outputs.agent_id }}"
          echo "Based on topic: ${{ steps.generate.outputs.topic }}"
          echo "Topic score: ${{ steps.generate.outputs.topic_score }}"
          echo "Spawn PR: #${{ steps.create_pr.outputs.pr_number }} (MERGED)"
          echo ""
          echo "‚úÖ Agent is now active and ready to work!"
          echo ""
          echo "The agent was dynamically created from recent learnings and is now:"
          echo "- Registered in the agent system"
          echo "- Available for issue assignments"
          echo "- Ready to contribute code"
          echo "- Competing in the performance system"

      - name: No learnings available
        if: steps.check_learnings.outputs.has_learnings == 'false'
        run: |
          echo "‚ö†Ô∏è No recent learnings found"
          echo "The learning workflows (Hacker News and TLDR) need to run first"
          echo "to provide data for agent generation."
          echo ""
          echo "Skipping agent spawn for now."

      - name: Capacity limit reached
        if: steps.check_learnings.outputs.has_learnings == 'true' && steps.check_capacity.outputs.can_spawn == 'false'
        run: |
          echo "‚ö†Ô∏è Cannot spawn new agent - capacity limit reached"
          echo "Active agents: ${{ steps.check_capacity.outputs.active_count }}/${{ steps.check_capacity.outputs.max_agents }}"
          echo ""
          echo "Wait for agent evaluation workflow to eliminate underperforming agents."
