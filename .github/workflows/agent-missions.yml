name: "Agent Missions"

# NOTE: This workflow is now part of the autonomous-pipeline.yml
# It can still be triggered manually or by workflow_run for backward compatibility
on:
  workflow_dispatch:
    inputs:
      learning_source:
        description: 'Source of learning that triggered missions'
        required: false
        type: string
  workflow_run:
    workflows: ["World Model Update"]
    types: [completed]

permissions:
  contents: write
  issues: write
  pull-requests: write

jobs:
  create-missions:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      
      - name: Install dependencies
        run: |
          pip install requests
      
      - name: Ensure required labels exist
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          python3 << 'EOF'
          import requests
          import os
          import sys
          
          GITHUB_TOKEN = os.environ['GH_TOKEN']
          REPO = os.environ['GITHUB_REPOSITORY']
          
          headers = {
              'Authorization': f'token {GITHUB_TOKEN}',
              'Accept': 'application/vnd.github.v3+json'
          }
          
          # Required labels for missions
          required_labels = [
              {'name': 'learning', 'color': '0E8A16', 'description': 'Related to learning and knowledge acquisition'},
              {'name': 'agent-mission', 'color': 'D93F0B', 'description': 'Mission assigned to autonomous agents'},
              {'name': 'ai-generated', 'color': '1D76DB', 'description': 'Content generated by AI'},
              {'name': 'automated', 'color': 'FBCA04', 'description': 'Automated workflow action'},
              {'name': 'world-model', 'color': '0052CC', 'description': 'Related to world model updates'},
          ]
          
          # Get existing labels
          url = f'https://api.github.com/repos/{REPO}/labels'
          response = requests.get(url, headers=headers)
          existing_labels = {label['name'].lower() for label in response.json()}
          
          print(f"Found {len(existing_labels)} existing labels")
          
          # Create missing labels
          for label in required_labels:
              label_name_lower = label['name'].lower()
              if label_name_lower not in existing_labels:
                  print(f"Creating label: {label['name']}")
                  create_url = f'https://api.github.com/repos/{REPO}/labels'
                  create_response = requests.post(create_url, headers=headers, json=label)
                  if create_response.status_code == 201:
                      print(f"  âœ… Created: {label['name']}")
                  else:
                      print(f"  âš ï¸  Failed to create {label['name']}: {create_response.text}")
              else:
                  print(f"  âœ“ Label exists: {label['name']}")
          
          print(f"\nâœ… All required labels are ready")
          EOF
      
      - name: Analyze world state and select agents
        id: select_agents
        run: |
          python3 << 'EOF'
          import json
          import os
          import sys
          import hashlib
          from datetime import datetime, timezone
          from pathlib import Path
          
          # Add world directory to Python path to import agent_learning_matcher
          sys.path.insert(0, str(Path(__file__).parent / 'world'))
          sys.path.insert(0, '/home/runner/work/Chained/Chained/world')
          
          try:
              from agent_learning_matcher import AgentLearningMatcher
              use_matcher = True
              print("âœ… Using AgentLearningMatcher for intelligent agent selection")
          except ImportError as e:
              print(f"âš ï¸  Could not import AgentLearningMatcher: {e}")
              print("âš ï¸  Falling back to simple scoring")
              use_matcher = False
          
          # Load world state
          with open('world/world_state.json', 'r') as f:
              world_state = json.load(f)
          
          # Load knowledge (ideas)
          with open('world/knowledge.json', 'r') as f:
              knowledge = json.load(f)
          
          # Load mission history for hash-based deduplication
          previous_mission_hashes = set()
          try:
              with open('.github/agent-system/missions_history.json', 'r') as f:
                  history = json.load(f)
                  previous_mission_hashes = set(history.get('mission_hashes', []))
                  print(f"âœ… Loaded {len(previous_mission_hashes)} previous mission hashes")
          except FileNotFoundError:
              print("âš ï¸  missions_history.json not found, will create new file")
          except Exception as e:
              print(f"âš ï¸  Error loading missions_history.json: {e}")
          
          print("ðŸŒ Analyzing World State")
          print(f"  Total agents: {len(world_state.get('agents', []))}")
          print(f"  Total ideas: {len(knowledge.get('ideas', []))}")
          print(f"  Total regions: {len(world_state.get('regions', []))}")
          
          agents = world_state.get('agents', [])
          ideas = knowledge.get('ideas', [])
          regions = world_state.get('regions', [])
          
          # Filter ideas: from learning_analysis AND not already having a mission
          # Check BOTH mission_created flag AND hash to ensure consistency
          recent_ideas = []
          for idea in ideas:
              if idea.get('source') != 'learning_analysis':
                  continue
              
              # Generate hash using SAME method as autonomous-pipeline.yml
              idea_id = idea.get('id', 'unknown')
              idea_title = idea.get('title', 'Unknown')
              idea_patterns = idea.get('patterns', [])
              mission_content = f"{idea_id}:{idea_title}:{':'.join(sorted(idea_patterns))}"
              mission_hash = hashlib.md5(mission_content.encode()).hexdigest()
              
              # Skip if EITHER flag is set OR hash exists
              if idea.get('mission_created', False):
                  print(f"  â­ï¸  Skipping '{idea_title[:40]}...' (mission_created flag)")
                  continue
              
              if mission_hash in previous_mission_hashes:
                  print(f"  â­ï¸  Skipping '{idea_title[:40]}...' (hash in history: {mission_hash[:8]})")
                  continue
              
              recent_ideas.append(idea)
          
          print(f"\nðŸ“Š Ideas without missions: {len(recent_ideas)}")
          
          if not recent_ideas:
              print("No new ideas to create missions for")
              with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                  f.write(f"has_missions=false\n")
              sys.exit(0)
          
          missions = []
          
          if use_matcher:
              # Use the sophisticated AgentLearningMatcher with diversity constraints
              matcher = AgentLearningMatcher()
              
              # Convert ideas to learning format for matcher
              learnings_for_matching = []
              for idea in recent_ideas[:10]:  # Process up to 10 ideas
                  learnings_for_matching.append({
                      'id': idea.get('id'),
                      'title': idea.get('title', 'Unknown'),
                      'description': idea.get('summary', ''),
                      'content': idea.get('description', ''),
                      'patterns': idea.get('patterns', []),
                      'source': 'learning_analysis'
                  })
              
              # Get diverse agent assignments (max 5)
              assignments = matcher.assign_learnings_to_agents_diverse(
                  learnings_for_matching,
                  agent_names=None,  # Use all agents
                  max_assignments=5,
                  min_score=0.1,  # Lower threshold for more flexibility
                  diversity_weight=0.7  # High diversity weight
              )
              
              print(f"\nðŸŽ¯ Matcher assigned {len(assignments)} missions with diversity")
              
              # Convert assignments to missions format
              for assignment in assignments:
                  agent_id = assignment['agent_id']
                  learning = assignment['learning']
                  
                  # Find the full idea and agent data
                  idea = next((i for i in recent_ideas if i.get('id') == learning['id']), None)
                  agent = next((a for a in agents if a.get('specialization') == agent_id), None)
                  
                  if idea and agent:
                      print(f"   âœ… {idea['title']} â†’ @{agent_id} (score: {assignment['score']:.2f}, rank: {assignment['assignment_rank']})")
                      
                      # Generate mission hash using SAME method as autonomous-pipeline.yml
                      idea_id = idea['id']
                      idea_title = idea['title']
                      idea_patterns = idea.get('patterns', [])
                      mission_content = f"{idea_id}:{idea_title}:{':'.join(sorted(idea_patterns))}"
                      mission_hash = hashlib.md5(mission_content.encode()).hexdigest()
                      
                      missions.append({
                          'idea_id': idea['id'],
                          'idea_title': idea['title'],
                          'idea_summary': idea.get('summary', '')[:200],
                          'patterns': idea.get('patterns', []),
                          'mission_hash': mission_hash,
                          'agent': {
                              'agent_id': agent.get('id'),
                              'agent_name': agent.get('label', 'Unknown'),
                              'specialization': agent_id,
                              'score': assignment['score'],
                              'location': agent.get('location_region_id', '')
                          },
                          'regions': [r.get('region_id') for r in idea.get('inspiration_regions', [])]
                      })
          
          else:
              # Fallback: Simple diverse selection (if matcher not available)
              print("\nâš ï¸  Using fallback diverse selection")
              from collections import defaultdict
              agent_assignment_count = defaultdict(int)
              
              for idea in recent_ideas[:5]:
                  idea_id = idea.get('id', 'unknown')
                  idea_title = idea.get('title', 'Unknown')
                  idea_patterns = idea.get('patterns', [])
                  idea_regions = idea.get('inspiration_regions', [])
                  
                  print(f"\nðŸŽ¯ Processing idea: {idea_title}")
                  
                  # Score all agents
                  agent_scores = []
                  for agent in agents:
                      specialization = agent.get('specialization', '')
                      if not specialization or specialization == 'unknown':
                          continue
                      
                      # Simple base score (all agents start equal)
                      base_score = 0.5
                      
                      # Apply diversity penalty
                      diversity_penalty = agent_assignment_count[specialization] * 0.7
                      adjusted_score = base_score * (1.0 - min(diversity_penalty, 0.9))
                      
                      agent_scores.append({
                          'agent_id': agent.get('id'),
                          'agent_name': agent.get('label', 'Unknown'),
                          'specialization': specialization,
                          'score': adjusted_score,
                          'location': agent.get('location_region_id', '')
                      })
                  
                  # Sort by adjusted score
                  agent_scores.sort(key=lambda x: x['score'], reverse=True)
                  
                  if agent_scores:
                      best_agent = agent_scores[0]
                      print(f"   Selected: {best_agent['agent_name']} (@{best_agent['specialization']}) - score: {best_agent['score']:.2f}")
                      
                      # Generate mission hash using SAME method as autonomous-pipeline.yml
                      mission_content = f"{idea_id}:{idea_title}:{':'.join(sorted(idea_patterns))}"
                      mission_hash = hashlib.md5(mission_content.encode()).hexdigest()
                      
                      missions.append({
                          'idea_id': idea_id,
                          'idea_title': idea_title,
                          'idea_summary': idea.get('summary', '')[:200],
                          'patterns': idea_patterns,
                          'mission_hash': mission_hash,
                          'agent': best_agent,
                          'regions': [r.get('region_id') for r in idea_regions]
                      })
                      
                      agent_assignment_count[best_agent['specialization']] += 1
          
          # Save missions data
          with open('missions_data.json', 'w') as f:
              json.dump(missions, f, indent=2)
          
          print(f"\nâœ… Created {len(missions)} missions")
          
          # Mark ideas as having missions created AND update missions_history.json
          for mission in missions:
              idea_id = mission['idea_id']
              for idea in ideas:
                  if idea.get('id') == idea_id:
                      idea['mission_created'] = True
                      idea['mission_created_at'] = datetime.now(timezone.utc).isoformat()
                      break
          
          # Save updated knowledge
          with open('world/knowledge.json', 'w') as f:
              json.dump(knowledge, f, indent=2)
          
          print(f"âœ… Marked {len(missions)} ideas as having missions")
          
          # Update missions_history.json with new hashes
          new_hashes = [m['mission_hash'] for m in missions]
          all_hashes = list(previous_mission_hashes) + new_hashes
          
          # Keep only the last 100 hashes to prevent unbounded growth
          if len(all_hashes) > 100:
              all_hashes = all_hashes[-100:]
          
          missions_history = {
              'last_updated': datetime.now(timezone.utc).isoformat(),
              'mission_hashes': all_hashes
          }
          
          with open('.github/agent-system/missions_history.json', 'w') as f:
              json.dump(missions_history, f, indent=2)
          
          print(f"âœ… Updated missions_history.json with {len(new_hashes)} new hashes (total: {len(all_hashes)})")
          
          # Output for GitHub Actions
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f"has_missions=true\n")
              f.write(f"mission_count={len(missions)}\n")
          
          EOF
      
      - name: Move agents in world model
        if: steps.select_agents.outputs.has_missions == 'true'
        run: |
          python3 << 'EOF'
          import json
          import os
          
          # Load missions data
          with open('missions_data.json', 'r') as f:
              missions = json.load(f)
          
          # Load world state
          with open('world/world_state.json', 'r') as f:
              world_state = json.load(f)
          
          print("ðŸš€ Moving agents to mission locations")
          
          agents = world_state.get('agents', [])
          agent_dict = {agent['id']: agent for agent in agents}
          
          for mission in missions:
              mission_regions = mission.get('regions', [])
              if not mission_regions:
                  continue
              
              target_region = mission_regions[0]  # Primary region
              
              # Move only the single assigned agent
              agent_data = mission.get('agent')
              if agent_data:
                  agent_id = agent_data['agent_id']
                  if agent_id in agent_dict:
                      agent = agent_dict[agent_id]
                      
                      # Update agent location and status
                      old_location = agent.get('location_region_id')
                      agent['location_region_id'] = target_region
                      agent['status'] = 'exploring'
                      agent['current_idea_id'] = mission.get('idea_id')
                      
                      # Add to path if moving
                      if old_location != target_region:
                          if 'path' not in agent:
                              agent['path'] = []
                          if target_region not in agent['path']:
                              agent['path'].append(target_region)
                      
                      print(f"  ðŸ“ {agent_data['agent_name']} â†’ {target_region}")
          
          # Update tick
          world_state['tick'] = world_state.get('tick', 0) + 1
          world_state['time'] = datetime.now(timezone.utc).isoformat()
          
          # Save updated world state
          with open('world/world_state.json', 'w') as f:
              json.dump(world_state, f, indent=2)
          
          print(f"\nâœ… Agents moved, tick: {world_state['tick']}")
          EOF
      
      - name: Create mission issues
        if: steps.select_agents.outputs.has_missions == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          chmod +x tools/create_mission_issues.py
          python3 tools/create_mission_issues.py
      
      - name: Assign agents to mission issues
        if: steps.select_agents.outputs.has_missions == 'true'
        env:
          GH_TOKEN: ${{ secrets.COPILOT_PAT || secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_REPOSITORY_OWNER: ${{ github.repository_owner }}
          GITHUB_REPOSITORY_NAME: ${{ github.event.repository.name }}
        run: |
          chmod +x tools/assign-agent-directly.sh
          
          # Check if created_missions.json exists
          if [ ! -f created_missions.json ]; then
            echo "âš ï¸  No created_missions.json found, skipping assignment"
            exit 0
          fi
          
          # Read created issues and assign agents
          echo "ðŸŽ¯ Assigning agents to created mission issues"
          
          # Use jq to parse the JSON and iterate
          jq -r '.[] | "\(.issue_number) \(.agent_specialization)"' created_missions.json | while read -r issue_number agent_specialization; do
            if [ -n "$issue_number" ] && [ -n "$agent_specialization" ]; then
              echo ""
              echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              echo "Assigning #$issue_number to @$agent_specialization"
              echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              
              ./tools/assign-agent-directly.sh "$issue_number" "$agent_specialization" || {
                echo "âš ï¸  Assignment failed for issue #$issue_number, continuing..."
              }
            fi
          done
          
          echo ""
          echo "âœ… Agent assignment process complete"
      
      - name: Commit world state changes
        if: steps.select_agents.outputs.has_missions == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          git add world/ .github/agent-system/missions_history.json
          
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            TIMESTAMP=$(date +%Y%m%d-%H%M%S)
            BRANCH_NAME="agent-missions/${TIMESTAMP}-${{ github.run_id }}"
            
            git checkout -b "$BRANCH_NAME"
            git commit -m "chore: agent missions created and assigned - ${{ steps.select_agents.outputs.mission_count }} missions"
            git push origin "$BRANCH_NAME"
            
            # Create PR with inline body to avoid YAML escaping issues
            cat << 'PRBODY' | gh pr create \
              --title "ðŸŽ¯ Agent Missions - $(date +%Y-%m-%d)" \
              --body-file - \
              --label "automated,agent-mission,world-model,copilot" \
              --base main \
              --head "$BRANCH_NAME"
            Agent missions automated by @meta-coordinator.
            
            Summary: Created ${{ steps.select_agents.outputs.mission_count }} new missions with diverse agent assignment.
            
            Changes:
            - Created GitHub issues for each mission
            - Used AgentLearningMatcher with diversity constraints (diversity_weight=0.7)
            - Assigned 1 unique agent per mission with penalty for repeat assignments
            - Marked ideas as 'mission_created' to prevent reprocessing
            - Updated missions_history.json with mission hashes for deduplication
            - Moved agents to mission locations
            - Updated world tick and agent status
            
            Key Improvements:
            - Now uses world/agent_learning_matcher.py for intelligent matching
            - Diversity penalty prevents same agent from monopolizing missions
            - Ideas are marked as processed to prevent duplicate missions
            - Mission hashes tracked in missions_history.json for cross-workflow consistency
            - Supports full agent roster, not limited pattern matching
            
            ---
            Automated by Agent Missions workflow (@meta-coordinator)
            PRBODY
          fi
      
      - name: Log summary
        run: |
          echo "===================="
          echo "Agent Missions Complete"
          echo "===================="
          echo "Missions created: ${{ steps.select_agents.outputs.mission_count || 0 }}"
          echo "Timestamp: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
