name: "Agent Missions"

# NOTE: This workflow is now part of the autonomous-pipeline.yml
# It can still be triggered manually or by workflow_run for backward compatibility
on:
  workflow_dispatch:
    inputs:
      learning_source:
        description: 'Source of learning that triggered missions'
        required: false
        type: string
  workflow_run:
    workflows: ["World Model Update"]
    types: [completed]

permissions:
  contents: write
  issues: write
  pull-requests: write

jobs:
  create-missions:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      
      - name: Install dependencies
        run: |
          pip install requests
      
      - name: Ensure required labels exist
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          python3 << 'EOF'
          import requests
          import os
          import sys
          
          GITHUB_TOKEN = os.environ['GH_TOKEN']
          REPO = os.environ['GITHUB_REPOSITORY']
          
          headers = {
              'Authorization': f'token {GITHUB_TOKEN}',
              'Accept': 'application/vnd.github.v3+json'
          }
          
          # Required labels for missions
          required_labels = [
              {'name': 'learning', 'color': '0E8A16', 'description': 'Related to learning and knowledge acquisition'},
              {'name': 'agent-mission', 'color': 'D93F0B', 'description': 'Mission assigned to autonomous agents'},
              {'name': 'ai-generated', 'color': '1D76DB', 'description': 'Content generated by AI'},
              {'name': 'automated', 'color': 'FBCA04', 'description': 'Automated workflow action'},
              {'name': 'world-model', 'color': '0052CC', 'description': 'Related to world model updates'},
          ]
          
          # Get existing labels
          url = f'https://api.github.com/repos/{REPO}/labels'
          response = requests.get(url, headers=headers)
          existing_labels = {label['name'].lower() for label in response.json()}
          
          print(f"Found {len(existing_labels)} existing labels")
          
          # Create missing labels
          for label in required_labels:
              label_name_lower = label['name'].lower()
              if label_name_lower not in existing_labels:
                  print(f"Creating label: {label['name']}")
                  create_url = f'https://api.github.com/repos/{REPO}/labels'
                  create_response = requests.post(create_url, headers=headers, json=label)
                  if create_response.status_code == 201:
                      print(f"  âœ… Created: {label['name']}")
                  else:
                      print(f"  âš ï¸  Failed to create {label['name']}: {create_response.text}")
              else:
                  print(f"  âœ“ Label exists: {label['name']}")
          
          print(f"\nâœ… All required labels are ready")
          EOF
      
      - name: Analyze world state and select agents
        id: select_agents
        run: |
          python3 << 'EOF'
          import json
          import os
          from datetime import datetime, timezone
          from collections import defaultdict
          
          # Load world state
          with open('world/world_state.json', 'r') as f:
              world_state = json.load(f)
          
          # Load knowledge (ideas)
          with open('world/knowledge.json', 'r') as f:
              knowledge = json.load(f)
          
          print("ðŸŒ Analyzing World State")
          print(f"  Total agents: {len(world_state.get('agents', []))}")
          print(f"  Total ideas: {len(knowledge.get('ideas', []))}")
          print(f"  Total regions: {len(world_state.get('regions', []))}")
          
          agents = world_state.get('agents', [])
          ideas = knowledge.get('ideas', [])
          regions = world_state.get('regions', [])
          
          # Find recently created ideas (from learning analysis)
          recent_ideas = [idea for idea in ideas if idea.get('source') == 'learning_analysis']
          print(f"\nðŸ“Š Recent ideas from learning: {len(recent_ideas)}")
          
          if not recent_ideas:
              print("No recent ideas to create missions for")
              with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                  f.write(f"has_missions=false\n")
              sys.exit(0)
          
          # For each recent idea, select top 10 relevant agents
          missions = []
          
          for idea in recent_ideas[:5]:  # Process top 5 ideas
              idea_id = idea.get('id', 'unknown')
              idea_title = idea.get('title', 'Unknown')
              idea_patterns = idea.get('patterns', [])
              idea_regions = idea.get('inspiration_regions', [])
              
              print(f"\nðŸŽ¯ Processing idea: {idea_title}")
              print(f"   Patterns: {', '.join(idea_patterns)}")
              
              # Score agents for this idea
              agent_scores = []
              
              for agent in agents:
                  score = 0.0
                  agent_id = agent.get('id')
                  specialization = agent.get('specialization', '')
                  agent_location = agent.get('location_region_id', '')
                  metrics = agent.get('metrics', {})
                  
                  # Location relevance (30%)
                  for region in idea_regions:
                      if agent_location == region.get('region_id'):
                          score += 0.3 * region.get('weight', 0.5)
                  
                  # Role/skill relevance (40%)
                  # Map patterns to agent specializations
                  pattern_matches = {
                      'ai': ['investigate-champion', 'engineer-master', 'create-guru'],
                      'cloud': ['infrastructure-specialist', 'engineer-master'],
                      'security': ['secure-specialist', 'secure-ninja', 'monitor-champion'],
                      'testing': ['assert-specialist', 'validator-pro'],
                      'devops': ['coordinate-wizard', 'align-wizard'],
                      'api': ['engineer-master', 'engineer-wizard'],
                  }
                  
                  for pattern in idea_patterns:
                      if specialization in pattern_matches.get(pattern, []):
                          score += 0.4
                  
                  # Performance score (30%)
                  overall_score = metrics.get('overall_score', 0.0)
                  score += 0.3 * overall_score
                  
                  agent_scores.append({
                      'agent_id': agent_id,
                      'agent_name': agent.get('label', 'Unknown'),
                      'specialization': specialization,
                      'score': score,
                      'location': agent_location
                  })
              
              # Sort by score and take only THE TOP 1 AGENT
              agent_scores.sort(key=lambda x: x['score'], reverse=True)
              best_agent = agent_scores[0] if agent_scores else None
              
              if best_agent:
                  print(f"   Selected BEST agent: {best_agent['agent_name']} ({best_agent['specialization']}) - score: {best_agent['score']:.2f}")
                  
                  missions.append({
                      'idea_id': idea_id,
                      'idea_title': idea_title,
                      'idea_summary': idea.get('summary', '')[:200],
                      'patterns': idea_patterns,
                      'agent': best_agent,  # Single agent, not list
                      'regions': [r.get('region_id') for r in idea_regions]
                  })
              else:
                  print(f"   âš ï¸  No agents available for this mission")
          
          # Save missions data
          with open('missions_data.json', 'w') as f:
              json.dump(missions, f, indent=2)
          
          print(f"\nâœ… Created {len(missions)} missions")
          
          # Output for GitHub Actions
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f"has_missions=true\n")
              f.write(f"mission_count={len(missions)}\n")
          
          EOF
      
      - name: Move agents in world model
        if: steps.select_agents.outputs.has_missions == 'true'
        run: |
          python3 << 'EOF'
          import json
          import os
          
          # Load missions data
          with open('missions_data.json', 'r') as f:
              missions = json.load(f)
          
          # Load world state
          with open('world/world_state.json', 'r') as f:
              world_state = json.load(f)
          
          print("ðŸš€ Moving agents to mission locations")
          
          agents = world_state.get('agents', [])
          agent_dict = {agent['id']: agent for agent in agents}
          
          for mission in missions:
              mission_regions = mission.get('regions', [])
              if not mission_regions:
                  continue
              
              target_region = mission_regions[0]  # Primary region
              
              # Move only the single assigned agent
              agent_data = mission.get('agent')
              if agent_data:
                  agent_id = agent_data['agent_id']
                  if agent_id in agent_dict:
                      agent = agent_dict[agent_id]
                      
                      # Update agent location and status
                      old_location = agent.get('location_region_id')
                      agent['location_region_id'] = target_region
                      agent['status'] = 'exploring'
                      agent['current_idea_id'] = mission.get('idea_id')
                      
                      # Add to path if moving
                      if old_location != target_region:
                          if 'path' not in agent:
                              agent['path'] = []
                          if target_region not in agent['path']:
                              agent['path'].append(target_region)
                      
                      print(f"  ðŸ“ {agent_data['agent_name']} â†’ {target_region}")
          
          # Update tick
          world_state['tick'] = world_state.get('tick', 0) + 1
          world_state['time'] = datetime.now(timezone.utc).isoformat()
          
          # Save updated world state
          with open('world/world_state.json', 'w') as f:
              json.dump(world_state, f, indent=2)
          
          print(f"\nâœ… Agents moved, tick: {world_state['tick']}")
          EOF
      
      - name: Create mission issues
        if: steps.select_agents.outputs.has_missions == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          chmod +x tools/create_mission_issues.py
          python3 tools/create_mission_issues.py
      
      - name: Assign agents to mission issues
        if: steps.select_agents.outputs.has_missions == 'true'
        env:
          GH_TOKEN: ${{ secrets.COPILOT_PAT || secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_REPOSITORY_OWNER: ${{ github.repository_owner }}
          GITHUB_REPOSITORY_NAME: ${{ github.event.repository.name }}
        run: |
          chmod +x tools/assign-agent-directly.sh
          
          # Check if created_missions.json exists
          if [ ! -f created_missions.json ]; then
            echo "âš ï¸  No created_missions.json found, skipping assignment"
            exit 0
          fi
          
          # Read created issues and assign agents
          echo "ðŸŽ¯ Assigning agents to created mission issues"
          
          # Use jq to parse the JSON and iterate
          jq -r '.[] | "\(.issue_number) \(.agent_specialization)"' created_missions.json | while read -r issue_number agent_specialization; do
            if [ -n "$issue_number" ] && [ -n "$agent_specialization" ]; then
              echo ""
              echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              echo "Assigning #$issue_number to @$agent_specialization"
              echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              
              ./tools/assign-agent-directly.sh "$issue_number" "$agent_specialization" || {
                echo "âš ï¸  Assignment failed for issue #$issue_number, continuing..."
              }
            fi
          done
          
          echo ""
          echo "âœ… Agent assignment process complete"
      
      - name: Commit world state changes
        if: steps.select_agents.outputs.has_missions == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          git add world/
          
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            TIMESTAMP=$(date +%Y%m%d-%H%M%S)
            BRANCH_NAME="agent-missions/${TIMESTAMP}-${{ github.run_id }}"
            
            git checkout -b "$BRANCH_NAME"
            git commit -m "chore: agent missions created and assigned - ${{ steps.select_agents.outputs.mission_count }} missions"
            git push origin "$BRANCH_NAME"
            
            # Create PR with inline body to avoid YAML escaping issues
            cat << 'PRBODY' | gh pr create \
              --title "ðŸŽ¯ Agent Missions - $(date +%Y-%m-%d)" \
              --body-file - \
              --label "automated,agent-mission,world-model,copilot" \
              --base main \
              --head "$BRANCH_NAME"
            Agent missions automated by @meta-coordinator.
            
            Summary: Created ${{ steps.select_agents.outputs.mission_count }} new missions with direct agent assignment.
            
            Changes:
            - Created GitHub issues for each mission
            - Assigned 1 best-match agent per mission (not 10)
            - Used direct GraphQL API assignment (no delay)
            - Moved agents to mission locations
            - Updated world tick and agent status
            
            Key Improvements: Previously missions listed 10 agents and relied on later workflow pickup. Now only the single best agent is selected and assigned immediately via GraphQL API.
            
            ---
            Automated by Agent Missions workflow (@meta-coordinator)
            PRBODY
          fi
      
      - name: Log summary
        run: |
          echo "===================="
          echo "Agent Missions Complete"
          echo "===================="
          echo "Missions created: ${{ steps.select_agents.outputs.mission_count || 0 }}"
          echo "Timestamp: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
