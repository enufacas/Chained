name: "Agent System: Evaluator"

on:
  schedule:
    # Run daily at midnight UTC
    - cron: '0 0 * * *'
  workflow_dispatch:
    inputs:
      force_evaluation:
        description: 'Force evaluation even if already run today'
        required: false
        type: boolean
        default: false


permissions:
  contents: write
  issues: write
  pull-requests: write
  actions: write

jobs:
  evaluate-agents:
    runs-on: ubuntu-latest
    outputs:
      has_results: ${{ steps.check_results.outputs.has_results }}
      pr_number: ${{ steps.create_pr.outputs.pr_number }}
      pr_created: ${{ steps.create_pr.outputs.pr_created }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Configure git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Ensure agent system labels exist
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "üè∑Ô∏è Checking agent system labels..."
          
          # Function to create label if it doesn't exist
          create_label_if_missing() {
            local name="$1"
            local color="$2"
            local description="$3"
            
            if gh label list --repo ${{ github.repository }} | grep -q "^${name}"; then
              echo "‚úì Label '$name' already exists"
            else
              gh label create "$name" --color "$color" --description "$description" --repo ${{ github.repository }} 2>/dev/null || echo "‚ö†Ô∏è Could not create label '$name'"
            fi
          }
          
          # Create evaluation-specific labels
          create_label_if_missing "agent-system" "7057ff" "Agent ecosystem activity"
          create_label_if_missing "evaluation" "e4e669" "Agent evaluations"
          create_label_if_missing "automated" "ededed" "Auto-generated content"
          create_label_if_missing "copilot" "8b5cf6" "Copilot-related tasks"

      - name: Evaluate all agents
        id: evaluate
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          python3 << 'PYTHON_SCRIPT'
          import json
          import subprocess
          import sys
          from datetime import datetime, timedelta
          
          # Use registry manager
          sys.path.insert(0, 'tools')
          from registry_manager import RegistryManager
          
          registry = RegistryManager()
          
          # Get active agents
          active_agents = registry.list_agents(status='active')
          
          if not active_agents:
              print("No active agents to evaluate")
              exit(0)
          
          total_agents = len(active_agents)
          print(f"üìä Evaluating {total_agents} active agents...")
          
          promoted = []
          eliminated = []
          maintained = []
          
          # Import the real metrics collector
          import importlib.util
          try:
              spec = importlib.util.spec_from_file_location(
                  "agent_metrics_collector",
                  "tools/agent-metrics-collector.py"
              )
              metrics_module = importlib.util.module_from_spec(spec)
              spec.loader.exec_module(metrics_module)
              MetricsCollector = metrics_module.MetricsCollector
              collector = MetricsCollector()
              use_real_metrics = True
              print("‚úÖ Using real GitHub metrics collector")
          except Exception as e:
              print(f"‚ö†Ô∏è  Warning: Could not load metrics collector, using fallback: {e}")
              use_real_metrics = False
          
          # Get config
          config = registry.get_config()
          protected_specializations = config.get('protected_specializations', [])
          elimination_threshold = config['elimination_threshold']
          promotion_threshold = config['promotion_threshold']
          grace_period_hours = config.get('new_agent_grace_period_hours', 48)
          minimum_score = config.get('new_agent_minimum_score', 0.40)
          
          # OPTIMIZATION: Batch fetch all issues once before evaluating agents
          batch_cache = None
          if use_real_metrics:
              try:
                  print("üöÄ Starting batch optimization...")
                  batch_cache = collector._batch_fetch_all_agent_issues(since_days=7)
                  print("‚úÖ Batch fetch complete. Starting agent evaluation...")
              except Exception as e:
                  print(f"‚ö†Ô∏è  Batch fetch failed, proceeding without cache: {e}")
          
          for idx, agent in enumerate(active_agents, 1):
              # Progress logging
              print(f"\n{'='*60}")
              print(f"üìä Evaluating agent {idx}/{total_agents}")
              print(f"{'='*60}")
              agent_id = agent['id']
              agent_name = agent['name']
              specialization = agent.get('specialization', '')
              
              print(f"Agent: {agent_name} ({agent_id})")
              print(f"Specialization: {specialization}")
              
              # Check if this agent is protected
              is_protected = specialization in protected_specializations
              
              if is_protected:
                  print(f"\n{agent_name}: üõ°Ô∏è PROTECTED (cannot be eliminated)")
                  maintained.append(agent)
                  continue
              
              # Check if agent is in grace period (new agent protection)
              spawned = datetime.fromisoformat(agent['spawned_at'].replace('Z', '+00:00'))
              age_hours = (datetime.utcnow().replace(tzinfo=spawned.tzinfo) - spawned).total_seconds() / 3600
              in_grace_period = age_hours < grace_period_hours
              
              if in_grace_period:
                  print(f"\n{agent_name}: üÜï IN GRACE PERIOD ({age_hours:.1f}h / {grace_period_hours}h)")
              
              if use_real_metrics:
                  # Use real GitHub activity metrics
                  try:
                      # Use batch cache to avoid redundant API calls
                      metrics = collector.collect_metrics(
                          agent_id, 
                          since_days=7,
                          use_batch_cache=True if batch_cache else False,
                          batch_cache=batch_cache
                      )
                      overall_score = metrics.scores.overall
                      
                      # Update all metrics from real data
                      agent['metrics']['issues_resolved'] = metrics.activity.issues_resolved
                      agent['metrics']['prs_merged'] = metrics.activity.prs_merged
                      agent['metrics']['reviews_given'] = metrics.activity.reviews_given
                      agent['metrics']['code_quality_score'] = metrics.scores.code_quality
                      agent['metrics']['creativity_score'] = metrics.scores.creativity
                      agent['metrics']['overall_score'] = overall_score
                      
                      print(f"\n{agent_name}: {overall_score:.2%} (real metrics)")
                      print(f"  üé® Creativity: {metrics.scores.creativity:.2%}")
                  except Exception as e:
                      print(f"‚ö†Ô∏è  Error collecting metrics for {agent_id}, using fallback: {e}")
                      # Fallback to time-based scoring if metrics collection fails
                      spawned = datetime.fromisoformat(agent['spawned_at'].replace('Z', '+00:00'))
                      age_hours = (datetime.utcnow().replace(tzinfo=spawned.tzinfo) - spawned).total_seconds() / 3600
                      overall_score = min(0.5, age_hours / 48.0)  # Conservative scoring for new agents
                      agent['metrics']['overall_score'] = overall_score
                      print(f"\n{agent_name}: {overall_score:.2%} (fallback)")
              else:
                  # Fallback: Use time-based scoring for new agents
                  spawned = datetime.fromisoformat(agent['spawned_at'].replace('Z', '+00:00'))
                  age_hours = (datetime.utcnow().replace(tzinfo=spawned.tzinfo) - spawned).total_seconds() / 3600
                  overall_score = min(0.5, age_hours / 48.0)  # Conservative scoring
                  agent['metrics']['overall_score'] = overall_score
                  print(f"\n{agent_name}: {overall_score:.2%} (fallback)")
              
              # Apply grace period protection: ensure minimum score
              if in_grace_period and overall_score < minimum_score:
                  print(f"   üÜï Grace period: Boosting from {overall_score:.2%} to {minimum_score:.2%}")
                  overall_score = minimum_score
                  agent['metrics']['overall_score'] = overall_score
              
              print(f"\n{agent_name}: {overall_score:.2%}")
              
              # Determine fate
              if overall_score >= promotion_threshold:
                  agent['status'] = 'hall_of_fame'
                  agent['promoted_at'] = datetime.utcnow().isoformat() + 'Z'
                  # Add to hall of fame
                  hall_of_fame = registry.get_hall_of_fame()
                  hall_of_fame.append(agent)
                  registry.update_hall_of_fame(hall_of_fame)
                  promoted.append(agent)
                  print(f"  üèÜ PROMOTED to Hall of Fame!")
              elif overall_score < elimination_threshold:
                  agent['status'] = 'eliminated'
                  agent['eliminated_at'] = datetime.utcnow().isoformat() + 'Z'
                  agent['elimination_reason'] = f"Score {overall_score:.2%} below threshold {elimination_threshold:.2%}"
                  eliminated.append(agent)
                  print(f"  ‚ùå ELIMINATED (score too low)")
              else:
                  maintained.append(agent)
                  print(f"  ‚úÖ Maintained (active)")
              
              # Update agent in registry
              registry.update_agent(agent)
          
          # Delete eliminated agents
          for agent in eliminated:
              registry.delete_agent(agent['id'])
          
          # Update metadata
          metadata = registry.get_metadata()
          metadata['last_evaluation'] = datetime.utcnow().isoformat() + 'Z'
          
          # Update system lead (highest scoring Hall of Fame member)
          hall_of_fame = registry.get_hall_of_fame()
          if hall_of_fame:
              top_agent = max(hall_of_fame, key=lambda a: a.get('metrics', {}).get('overall_score', 0))
              metadata['system_lead'] = top_agent['id']
              print(f"\nüëë System Lead: {top_agent['name']}")
          
          registry.update_metadata(metadata)
          
          # Output results
          print(f"\nüìä Evaluation Summary:")
          print(f"  üèÜ Promoted: {len(promoted)}")
          print(f"  ‚ùå Eliminated: {len(eliminated)}")
          print(f"  ‚úÖ Maintained: {len(maintained)}")
          
          # Save results for next steps (include specialization for archiving)
          with open('/tmp/evaluation_results.json', 'w') as f:
              json.dump({
                  'promoted': [{'id': a['id'], 'name': a['name'], 'score': a['metrics']['overall_score'], 'specialization': a.get('specialization', 'unknown')} for a in promoted],
                  'eliminated': [{'id': a['id'], 'name': a['name'], 'score': a['metrics']['overall_score'], 'specialization': a.get('specialization', 'unknown')} for a in eliminated],
                  'maintained': [{'id': a['id'], 'name': a['name'], 'score': a['metrics']['overall_score'], 'specialization': a.get('specialization', 'unknown')} for a in maintained]
              }, f, indent=2)
          
          PYTHON_SCRIPT

      - name: Sync agent registry to GitHub Pages
        run: |
          # Create docs/data/agents directory if it doesn't exist
          mkdir -p docs/data/agents
          
          # Copy registry to GitHub Pages
          cp .github/agent-system/registry.json docs/data/agents/agent-registry.json
          
          echo "‚úÖ Agent registry synced to GitHub Pages (docs/data/agents/agent-registry.json)"
          
          # Check if there are results to process
          if [ -f "/tmp/evaluation_results.json" ]; then
            echo "has_results=true" >> $GITHUB_OUTPUT
          else
            echo "has_results=false" >> $GITHUB_OUTPUT
          fi

      - name: Check for evaluation results
        id: check_results
        run: |
          if [ -f "/tmp/evaluation_results.json" ]; then
            echo "has_results=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Evaluation results available"
          else
            echo "has_results=false" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è No evaluation results"
          fi

      - name: Update agent profiles
        if: steps.check_results.outputs.has_results == 'true'
        run: |
          python3 << 'PYTHON_SCRIPT'
          import json
          import os
          
          with open('/tmp/evaluation_results.json', 'r') as f:
              results = json.load(f)
          
          # Update profiles for eliminated agents
          for agent in results.get('eliminated', []):
              profile_path = f".github/agent-system/profiles/{agent['id']}.md"
              if os.path.exists(profile_path):
                  with open(profile_path, 'r') as f:
                      content = f.read()
                  
                  # Update status
                  content = content.replace('**Status**: üü¢ Active', f"**Status**: ‚ùå Eliminated (Score: {agent['score']:.2%})")
                  
                  with open(profile_path, 'w') as f:
                      f.write(content)
          
          # Update profiles for promoted agents
          for agent in results.get('promoted', []):
              profile_path = f".github/agent-system/profiles/{agent['id']}.md"
              if os.path.exists(profile_path):
                  with open(profile_path, 'r') as f:
                      content = f.read()
                  
                  # Update status
                  content = content.replace('**Status**: üü¢ Active', f"**Status**: üèÜ Hall of Fame (Score: {agent['score']:.2%})")
                  
                  with open(profile_path, 'w') as f:
                      f.write(content)
          
          print("‚úÖ Agent profiles updated")
          PYTHON_SCRIPT

      - name: Archive eliminated agents
        if: steps.check_results.outputs.has_results == 'true'
        run: |
          mkdir -p .github/agent-system/archive
          mkdir -p .github/agent-system/archive/definitions
          
          python3 << 'PYTHON_SCRIPT'
          import json
          import shutil
          import os
          import sys
          from pathlib import Path
          
          # Use registry manager
          sys.path.insert(0, 'tools')
          from registry_manager import RegistryManager
          
          with open('/tmp/evaluation_results.json', 'r') as f:
              results = json.load(f)
          
          registry = RegistryManager()
          
          for agent in results.get('eliminated', []):
              agent_id = agent['id']
              agent_name = agent['name']
              
              # Archive profile
              profile_path = f".github/agent-system/profiles/{agent_id}.md"
              archive_path = f".github/agent-system/archive/{agent_id}.md"
              
              if os.path.exists(profile_path):
                  shutil.move(profile_path, archive_path)
                  print(f"üì¶ Archived profile for {agent_name}")
              
              # Find and note the agent definition (but don't remove it - keep for future spawns)
              # Get specialization from evaluation results (already includes it)
              specialization = agent.get('specialization', 'unknown')
              agent_def_path = Path(f".github/agents/{specialization}.md")
              
              if agent_def_path.exists():
                  print(f"  ‚ÑπÔ∏è  Agent definition {specialization}.md remains for future spawns")
              else:
                  print(f"  ‚ö†Ô∏è  Agent definition {specialization}.md not found")
          
          PYTHON_SCRIPT

      - name: Create evaluation PR
        id: create_pr
        if: steps.check_results.outputs.has_results == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          BRANCH_NAME="agent-evaluation/$(date +%Y%m%d-%H%M%S)"
          git checkout -b "$BRANCH_NAME"
          
          git add .github/agent-system/
          git add docs/data/agents/agent-registry.json
          git commit -m "üîÑ Daily agent evaluation and governance"
          git push origin "$BRANCH_NAME"
          
          # Read results
          PROMOTED_COUNT=$(python3 -c "
          import json
          with open('/tmp/evaluation_results.json', 'r') as f:
              results = json.load(f)
          print(len(results.get('promoted', [])))
          ")
          
          ELIMINATED_COUNT=$(python3 -c "
          import json
          with open('/tmp/evaluation_results.json', 'r') as f:
              results = json.load(f)
          print(len(results.get('eliminated', [])))
          ")
          
          MAINTAINED_COUNT=$(python3 -c "
          import json
          with open('/tmp/evaluation_results.json', 'r') as f:
              results = json.load(f)
          print(len(results.get('maintained', [])))
          ")
          
          # Build PR body
          PR_BODY="## üèõÔ∏è Daily Agent Evaluation Results

          The agent ecosystem has been evaluated based on performance metrics.

          ### Summary

          - üèÜ **Promoted to Hall of Fame**: $PROMOTED_COUNT agents
          - ‚ùå **Eliminated**: $ELIMINATED_COUNT agents  
          - ‚úÖ **Maintained Active Status**: $MAINTAINED_COUNT agents

          ### Details
          "
          
          # Add promoted agents
          if [ "$PROMOTED_COUNT" -gt 0 ]; then
            PR_BODY="$PR_BODY

          #### üèÜ Promoted to Hall of Fame
          "
            python3 << 'PYTHON_SCRIPT'
          import json
          with open('/tmp/evaluation_results.json', 'r') as f:
              results = json.load(f)
          for agent in results.get('promoted', []):
              print(f"- **{agent['name']}** - Score: {agent['score']:.2%}")
          PYTHON_SCRIPT
          fi
          
          # Add eliminated agents
          if [ "$ELIMINATED_COUNT" -gt 0 ]; then
            PR_BODY="$PR_BODY

          #### ‚ùå Eliminated
          "
            python3 << 'PYTHON_SCRIPT'
          import json
          with open('/tmp/evaluation_results.json', 'r') as f:
              results = json.load(f)
          for agent in results.get('eliminated', []):
              print(f"- **{agent['name']}** - Score: {agent['score']:.2%} (below threshold)")
          PYTHON_SCRIPT
          fi
          
          PR_BODY="$PR_BODY

          ### Changes

          - Updated agent registry
          - Modified agent profiles  
          - Archived eliminated agents
          - Updated system lead if applicable

          ---
          *ü§ñ Automated agent evaluation system - Survival of the fittest in action!*"
          
          PR_URL=$(gh pr create \
            --title "üèõÔ∏è Daily Agent Evaluation - $(date +%Y-%m-%d)" \
            --body "$PR_BODY" \
            --label "agent-system,evaluation,automated,copilot,auto-merge" \
            --base main \
            --head "$BRANCH_NAME")
          
          # Extract PR number
          PR_NUMBER=$(echo "$PR_URL" | grep -oE '[0-9]+$')
          echo "Created PR #${PR_NUMBER}: ${PR_URL}"
          echo "pr_number=${PR_NUMBER}" >> $GITHUB_OUTPUT
          echo "pr_created=true" >> $GITHUB_OUTPUT
          echo "‚úÖ Evaluation PR created: #${PR_NUMBER}"

      - name: Create evaluation report issue
        if: steps.check_results.outputs.has_results == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          python3 << 'PYTHON_SCRIPT'
          import json
          import subprocess
          import sys
          from datetime import datetime
          
          # Use registry manager
          sys.path.insert(0, 'tools')
          from registry_manager import RegistryManager
          
          with open('/tmp/evaluation_results.json', 'r') as f:
              results = json.load(f)
          
          registry = RegistryManager()
          
          title = f"üèõÔ∏è Agent Evaluation Report - {datetime.utcnow().strftime('%Y-%m-%d')}"
          
          # Get data using proper RegistryManager methods
          active_agents = registry.list_agents(status='active')
          hall_of_fame = registry.get_hall_of_fame()
          metadata = registry.get_metadata()
          system_lead_id = metadata.get('system_lead')
          
          body = f"""## üìä Daily Agent Evaluation Report

          **Date**: {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S')} UTC

          ### Results Summary

          - üèÜ **Promoted**: {len(results.get('promoted', []))} agents
          - ‚ùå **Eliminated**: {len(results.get('eliminated', []))} agents
          - ‚úÖ **Maintained**: {len(results.get('maintained', []))} agents
          - üìä **Total Active**: {len(active_agents)} agents

          ### Hall of Fame

          """
          
          if hall_of_fame:
              body += f"{len(hall_of_fame)} agents have earned their place:\n\n"
              for hof_agent in sorted(hall_of_fame, key=lambda a: a['metrics']['overall_score'], reverse=True):
                  score = hof_agent['metrics']['overall_score']
                  is_lead = hof_agent['id'] == system_lead_id
                  crown = "üëë " if is_lead else ""
                  body += f"- {crown}**{hof_agent['name']}** - {score:.2%}\n"
          else:
              body += "*No agents in Hall of Fame yet*\n"
          
          body += "\n### System Lead\n\n"
          
          if system_lead_id:
              lead = next((a for a in hall_of_fame if a['id'] == system_lead_id), None)
              if lead:
                  body += f"üëë **{lead['name']}** is currently governing the agent ecosystem.\n"
          else:
              body += "*No system lead elected yet*\n"
          
          body += """
          ### Performance Metrics

          Agents are evaluated on:
          - **Code Quality** (30%): Linting, best practices, maintainability
          - **Issue Resolution** (20%): Issues completed, time to resolution
          - **PR Success** (20%): PRs merged, review feedback
          - **Peer Review** (15%): Reviews provided, quality of feedback
          - **üé® Creativity** (15%): Novel solutions, diverse approaches, impactful changes

          ### Next Steps

          - New agents will continue spawning every 3 hours
          - Next evaluation in 24 hours
          - Community feedback influences agent scores

          ---
          *ü§ñ Automated evaluation - May the best agents thrive!*
          """
          
          # Create issue using gh CLI
          result = subprocess.run(
              ['gh', 'issue', 'create', '--title', title, '--body', body, '--label', 'agent-system,evaluation'],
              capture_output=True,
              text=True
          )
          
          if result.returncode == 0:
              print("‚úÖ Evaluation report issue created")
          else:
              print(f"‚ö†Ô∏è Failed to create issue: {result.stderr}")
          
          PYTHON_SCRIPT

  # ============================================================================
  # STAGE 2: MERGE EVALUATION PR (Parallelized with Stage 3)
  # ============================================================================
  
  merge-evaluation-pr:
    name: "Stage 2: Merge Evaluation PR"
    runs-on: ubuntu-latest
    needs: evaluate-agents
    if: always() && !cancelled() && needs.evaluate-agents.outputs.pr_created == 'true'
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Trigger Auto Review and Merge
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PR_NUMBER="${{ needs.evaluate-agents.outputs.pr_number }}"
          echo "üîÑ Triggering Auto Review & Merge workflow for PR #$PR_NUMBER..."
          
          # Trigger the auto-review-merge workflow with the specific PR number
          gh workflow run auto-review-merge.yml \
            --repo ${{ github.repository }} \
            -f pr_number="$PR_NUMBER"
          
          echo "‚úÖ Auto-review workflow triggered for PR #$PR_NUMBER"

      - name: Wait for PR to be merged
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PR_NUMBER="${{ needs.evaluate-agents.outputs.pr_number }}"
          echo "‚è≥ Waiting for PR #$PR_NUMBER to be merged by auto-review workflow..."
          
          # Give auto-review-merge workflow time to start processing
          echo "   Giving auto-review workflow 8 seconds to start..."
          sleep 8
          
          # Wait up to 2 minutes with optimized exponential backoff
          MAX_WAIT=120  # 2 minutes (reduced from 3)
          ELAPSED=8  # Already waited 8 seconds
          WAIT_INTERVAL=2  # Start with 2 seconds (reduced from 3)
          CHECK_COUNT=0
          
          while [ $ELAPSED -lt $MAX_WAIT ]; do
            CHECK_COUNT=$((CHECK_COUNT + 1))
            
            # Check PR state - use --json to get full state including merged status
            PR_DATA=$(gh pr view "$PR_NUMBER" --repo ${{ github.repository }} --json state,mergedAt,closed)
            PR_STATE=$(echo "$PR_DATA" | jq -r '.state')
            MERGED_AT=$(echo "$PR_DATA" | jq -r '.mergedAt')
            IS_CLOSED=$(echo "$PR_DATA" | jq -r '.closed')
            
            # Check if merged (mergedAt will be non-null if merged)
            if [ "$MERGED_AT" != "null" ] && [ "$MERGED_AT" != "" ]; then
              echo "‚úÖ PR #$PR_NUMBER was merged successfully! (verified in ${ELAPSED}s after $CHECK_COUNT checks)"
              echo "üéâ Evaluation PR merged - continuing to world model update"
              exit 0
            elif [ "$PR_STATE" = "MERGED" ]; then
              echo "‚úÖ PR #$PR_NUMBER has been merged successfully! (detected in ${ELAPSED}s after $CHECK_COUNT checks)"
              echo "üéâ Evaluation PR merged - continuing to world model update"
              exit 0
            elif [ "$IS_CLOSED" = "true" ] && [ "$MERGED_AT" = "null" ]; then
              echo "‚ö†Ô∏è PR #$PR_NUMBER was closed without merging"
              echo "This may indicate an issue with the auto-review process"
              exit 1
            elif [ "$PR_STATE" = "CLOSED" ]; then
              # Double-check if it was actually merged
              MERGED_CHECK=$(gh pr view "$PR_NUMBER" --repo ${{ github.repository }} --json mergedAt --jq '.mergedAt')
              if [ "$MERGED_CHECK" != "null" ] && [ "$MERGED_CHECK" != "" ]; then
                echo "‚úÖ PR #$PR_NUMBER was merged successfully! (verified in ${ELAPSED}s)"
                echo "üéâ Evaluation PR merged - continuing to world model update"
                exit 0
              else
                echo "‚ö†Ô∏è PR #$PR_NUMBER was closed without merging"
                exit 1
              fi
            fi
            
            # Still waiting - sleep and then update elapsed time
            echo "   Check $CHECK_COUNT: PR #$PR_NUMBER is $PR_STATE, waiting ${WAIT_INTERVAL}s... (${ELAPSED}s elapsed)"
            sleep $WAIT_INTERVAL
            ELAPSED=$((ELAPSED + WAIT_INTERVAL))
            
            # Exponential backoff: double wait time, max 20 seconds (optimized)
            if [ $WAIT_INTERVAL -lt 20 ]; then
              WAIT_INTERVAL=$((WAIT_INTERVAL * 2))
            fi
          done
          
          # Timeout reached - do final check
          echo "‚è∞ Timeout reached after ${ELAPSED}s"
          FINAL_CHECK=$(gh pr view "$PR_NUMBER" --repo ${{ github.repository }} --json state,mergedAt --jq '{state: .state, mergedAt: .mergedAt}')
          echo "Final PR state: $FINAL_CHECK"
          
          FINAL_MERGED=$(echo "$FINAL_CHECK" | jq -r '.mergedAt')
          if [ "$FINAL_MERGED" != "null" ] && [ "$FINAL_MERGED" != "" ]; then
            echo "‚úÖ PR #$PR_NUMBER was actually merged! (confirmed on final check)"
            exit 0
          fi
          
          echo "‚ùå PR #$PR_NUMBER was not merged within ${MAX_WAIT} seconds"
          echo "Check PR status at: https://github.com/${{ github.repository }}/pull/$PR_NUMBER"
          exit 1

  # ============================================================================
  # STAGE 3: SYNC TO WORLD MODEL (Runs in parallel with Stage 2)
  # ============================================================================
  
  sync-to-world:
    name: "Stage 3: Sync Agents to World Model"
    runs-on: ubuntu-latest
    needs: evaluate-agents  # Removed merge-evaluation-pr dependency for parallelization
    if: always() && !cancelled() && needs.evaluate-agents.outputs.has_results == 'true'
    outputs:
      has_changes: ${{ steps.world_sync.outputs.has_changes }}
      pr_number: ${{ steps.world_pr.outputs.pr_number }}
      pr_created: ${{ steps.world_pr.outputs.pr_created }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: main  # Checkout main after evaluation PR is merged

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          pip install -r requirements.txt || echo "‚ö†Ô∏è No requirements.txt, continuing..."

      - name: Sync agents to world model
        id: world_sync
        run: |
          echo "üåç Syncing agent evaluation results to world model..."
          
          # Sync agents from registry to world
          if [ -f "world/sync_agents_to_world.py" ]; then
            python3 world/sync_agents_to_world.py 2>&1 || echo "‚ö†Ô∏è Agent sync warning (continuing)"
          else
            echo "‚ö†Ô∏è world/sync_agents_to_world.py not found, skipping agent sync"
          fi
          
          # Update agent state
          if [ -f "scripts/update_agent.py" ]; then
            python3 scripts/update_agent.py 2>&1 || echo "‚ö†Ô∏è Agent state update warning (continuing)"
          else
            echo "‚ö†Ô∏è scripts/update_agent.py not found, skipping state update"
          fi
          
          # Sync to docs for GitHub Pages
          mkdir -p docs/world
          if [ -f "world/world_state.json" ]; then
            cp world/world_state.json docs/world/
            echo "‚úÖ Synced world_state.json to docs/world/"
          fi
          if [ -f "world/knowledge.json" ]; then
            cp world/knowledge.json docs/world/
            echo "‚úÖ Synced knowledge.json to docs/world/"
          fi
          
          # Check for changes
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          git add world/ docs/world/ 2>/dev/null || true
          if git diff --staged --quiet; then
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è No world model changes needed"
          else
            echo "has_changes=true" >> $GITHUB_OUTPUT
            echo "‚úÖ World model updated with agent evaluation data"
          fi

      - name: Create PR with world updates
        id: world_pr
        if: steps.world_sync.outputs.has_changes == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          BRANCH_NAME="agent-eval-world-sync/${TIMESTAMP}-${{ github.run_id }}"
          
          git checkout -b "$BRANCH_NAME"
          git commit -m "üåç World Model: Agent Evaluation Sync"
          git push origin "$BRANCH_NAME"
          
          # Create PR
          PR_URL=$(gh pr create \
            --title "üåç World Model: Agent Evaluation Sync - $(date +%Y-%m-%d)" \
            --body "## üåç World Model Sync: Agent Evaluation
          
          **Pipeline Run:** [View Details](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          
          Updates:
          - ‚úÖ Agent positions synchronized from evaluation
          - ‚úÖ Agent registry data reflected in world state
          - ‚úÖ World model updated for agent environment
          
          **Note:** This PR will be auto-merged by the next pipeline stage.
          
          This sync ensures agents have access to updated evaluation data in their world model environment.
          " \
            --label "automated,world-model,agent-system,auto-merge,copilot" \
            --base main \
            --head "$BRANCH_NAME")
          
          # Extract PR number
          PR_NUMBER=$(echo "$PR_URL" | grep -oE '[0-9]+$')
          echo "Created PR #${PR_NUMBER}: ${PR_URL}"
          echo "pr_number=${PR_NUMBER}" >> $GITHUB_OUTPUT
          echo "pr_created=true" >> $GITHUB_OUTPUT

  # ============================================================================
  # STAGE 4: MERGE WORLD MODEL PR
  # ============================================================================
  
  merge-world-pr:
    name: "Stage 4: Merge World Model PR"
    runs-on: ubuntu-latest
    needs: [sync-to-world, merge-evaluation-pr]  # Wait for both stage 2 and 3
    if: always() && !cancelled() && needs.sync-to-world.outputs.pr_created == 'true'
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Trigger Auto Review and Merge
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PR_NUMBER="${{ needs.sync-to-world.outputs.pr_number }}"
          echo "üîÑ Triggering Auto Review & Merge workflow for PR #$PR_NUMBER..."
          
          # Trigger the auto-review-merge workflow with the specific PR number
          gh workflow run auto-review-merge.yml \
            --repo ${{ github.repository }} \
            -f pr_number="$PR_NUMBER"
          
          echo "‚úÖ Auto-review workflow triggered for PR #$PR_NUMBER"

      - name: Wait for PR to be merged
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PR_NUMBER="${{ needs.sync-to-world.outputs.pr_number }}"
          echo "‚è≥ Waiting for PR #$PR_NUMBER to be merged by auto-review workflow..."
          
          # Give auto-review-merge workflow time to start processing
          echo "   Giving auto-review workflow 8 seconds to start..."
          sleep 8
          
          # Wait up to 2 minutes with optimized exponential backoff
          MAX_WAIT=120  # 2 minutes (reduced from 3)
          ELAPSED=8  # Already waited 8 seconds
          WAIT_INTERVAL=2  # Start with 2 seconds (optimized)
          CHECK_COUNT=0
          
          while [ $ELAPSED -lt $MAX_WAIT ]; do
            CHECK_COUNT=$((CHECK_COUNT + 1))
            
            # Check PR state - use --json to get full state including merged status
            PR_DATA=$(gh pr view "$PR_NUMBER" --repo ${{ github.repository }} --json state,mergedAt,closed)
            PR_STATE=$(echo "$PR_DATA" | jq -r '.state')
            MERGED_AT=$(echo "$PR_DATA" | jq -r '.mergedAt')
            IS_CLOSED=$(echo "$PR_DATA" | jq -r '.closed')
            
            # Check if merged (mergedAt will be non-null if merged)
            if [ "$MERGED_AT" != "null" ] && [ "$MERGED_AT" != "" ]; then
              echo "‚úÖ PR #$PR_NUMBER was merged successfully! (verified in ${ELAPSED}s after $CHECK_COUNT checks)"
              echo "üéâ World model PR merged - agent evaluation pipeline complete!"
              exit 0
            elif [ "$PR_STATE" = "MERGED" ]; then
              echo "‚úÖ PR #$PR_NUMBER has been merged successfully! (detected in ${ELAPSED}s after $CHECK_COUNT checks)"
              echo "üéâ World model PR merged - agent evaluation pipeline complete!"
              exit 0
            elif [ "$IS_CLOSED" = "true" ] && [ "$MERGED_AT" = "null" ]; then
              echo "‚ö†Ô∏è PR #$PR_NUMBER was closed without merging"
              echo "This may indicate an issue with the auto-review process"
              exit 1
            elif [ "$PR_STATE" = "CLOSED" ]; then
              # Double-check if it was actually merged
              MERGED_CHECK=$(gh pr view "$PR_NUMBER" --repo ${{ github.repository }} --json mergedAt --jq '.mergedAt')
              if [ "$MERGED_CHECK" != "null" ] && [ "$MERGED_CHECK" != "" ]; then
                echo "‚úÖ PR #$PR_NUMBER was merged successfully! (verified in ${ELAPSED}s)"
                echo "üéâ World model PR merged - agent evaluation pipeline complete!"
                exit 0
              else
                echo "‚ö†Ô∏è PR #$PR_NUMBER was closed without merging"
                exit 1
              fi
            fi
            
            # Still waiting - sleep and then update elapsed time
            echo "   Check $CHECK_COUNT: PR #$PR_NUMBER is $PR_STATE, waiting ${WAIT_INTERVAL}s... (${ELAPSED}s elapsed)"
            sleep $WAIT_INTERVAL
            ELAPSED=$((ELAPSED + WAIT_INTERVAL))
            
            # Exponential backoff: double wait time, max 20 seconds (optimized)
            if [ $WAIT_INTERVAL -lt 20 ]; then
              WAIT_INTERVAL=$((WAIT_INTERVAL * 2))
            fi
          done
          
          # Timeout reached - do final check
          echo "‚è∞ Timeout reached after ${ELAPSED}s"
          FINAL_CHECK=$(gh pr view "$PR_NUMBER" --repo ${{ github.repository }} --json state,mergedAt --jq '{state: .state, mergedAt: .mergedAt}')
          echo "Final PR state: $FINAL_CHECK"
          
          FINAL_MERGED=$(echo "$FINAL_CHECK" | jq -r '.mergedAt')
          if [ "$FINAL_MERGED" != "null" ] && [ "$FINAL_MERGED" != "" ]; then
            echo "‚úÖ PR #$PR_NUMBER was actually merged! (confirmed on final check)"
            exit 0
          fi
          
          echo "‚ùå PR #$PR_NUMBER was not merged within ${MAX_WAIT} seconds"
          echo "Check PR status at: https://github.com/${{ github.repository }}/pull/$PR_NUMBER"
          exit 1

  # ============================================================================
  # STAGE 5: SUMMARY
  # ============================================================================

  pipeline-summary:
    name: "Stage 5: Pipeline Summary"
    runs-on: ubuntu-latest
    needs: [evaluate-agents, merge-evaluation-pr, sync-to-world, merge-world-pr]
    if: always() && !cancelled()
    
    steps:
      - name: Summary
        run: |
          echo "üèõÔ∏è Agent Evaluation Pipeline Complete!"
          echo ""
          echo "Pipeline Stages:"
          echo "  Stage 1: Agent Evaluation - ${{ needs.evaluate-agents.result }}"
          echo "  Stage 2: Merge Evaluation PR - ${{ needs.merge-evaluation-pr.result }}"
          echo "  Stage 3: Sync to World Model - ${{ needs.sync-to-world.result }}"
          echo "  Stage 4: Merge World Model PR - ${{ needs.merge-world-pr.result }}"
          echo ""
          if [ "${{ needs.evaluate-agents.outputs.has_results }}" = "true" ]; then
            echo "‚úÖ Agent evaluation completed with results"
            echo "   Evaluation PR: #${{ needs.evaluate-agents.outputs.pr_number }}"
            if [ "${{ needs.sync-to-world.outputs.pr_created }}" = "true" ]; then
              echo "   World Model PR: #${{ needs.sync-to-world.outputs.pr_number }}"
            fi
          else
            echo "‚ÑπÔ∏è No agents to evaluate"
          fi
          echo ""
          echo "üéâ Multi-stage agent evaluation pipeline completed!"
