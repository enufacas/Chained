name: "Agent System: Spawner"

on:
  schedule:
    # Run every 3 hours
    - cron: '0 */3 * * *'
  workflow_dispatch:
    inputs:
      mode:
        description: 'Spawning mode'
        required: false
        type: choice
        default: 'mixed'
        options:
          - mixed  # 50% existing, 50% new random agents
          - existing  # Only use existing agent definitions
          - new  # Always create new random agents
      specialization:
        description: 'Force specific specialization (leave empty for random, only works with existing mode)'
        required: false
        type: string
      delete_mode:
        description: 'Delete agents before spawning'
        required: false
        type: choice
        default: 'none'
        options:
          - none  # Don't delete any agents
          - all  # Delete all active agents and respawn
          - specific  # Delete specific agent IDs (provide in delete_agent_ids)
      delete_agent_ids:
        description: 'Comma-separated agent IDs to delete (only used with delete_mode=specific, e.g., "agent-123,agent-456")'
        required: false
        type: string
      respawn_count:
        description: 'Number of agents to spawn after deletion (default: 1, max: 5)'
        required: false
        type: number
        default: 1

permissions:
  contents: write
  issues: write
  pull-requests: write

jobs:
  spawn-agent:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Configure git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Ensure agent system labels exist
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "üè∑Ô∏è Checking and creating agent system labels..."
          
          # Function to create label if it doesn't exist
          create_label_if_missing() {
            local name="$1"
            local color="$2"
            local description="$3"
            
            # Check if label exists by checking for the exact name with word boundary
            if gh label list --repo ${{ github.repository }} | grep -q "^${name}[[:space:]]"; then
              echo "‚úì Label '$name' already exists, skipping creation"
            else
              # Try to create the label, will fail if it exists
              if gh label create "$name" --color "$color" --description "$description" --repo ${{ github.repository }} 2>&1; then
                echo "‚úÖ Created label '$name'"
              else
                echo "‚úì Label '$name' already exists (detected during creation attempt)"
              fi
            fi
          }
          
          # Create all agent system labels
          create_label_if_missing "agent-system" "7057ff" "Agent ecosystem activity"
          create_label_if_missing "agent-work" "0e8a16" "Work assigned to agents"
          create_label_if_missing "spawn-pending" "d4c5f9" "Waiting for agent spawn PR to merge"
          create_label_if_missing "announcement" "0075ca" "Agent announcements"
          create_label_if_missing "evaluation" "e4e669" "Agent evaluations"
          create_label_if_missing "automated" "ededed" "Auto-generated content"
          create_label_if_missing "copilot" "8b5cf6" "Copilot-related tasks"
          
          echo "‚úÖ All agent system labels verified"

      - name: Delete agents if requested
        id: delete_agents
        if: github.event.inputs.delete_mode != 'none' && github.event.inputs.delete_mode != ''
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          DELETE_MODE="${{ github.event.inputs.delete_mode }}"
          DELETE_AGENT_IDS="${{ github.event.inputs.delete_agent_ids }}"
          REGISTRY_FILE=".github/agent-system/registry.json"
          
          echo "üóëÔ∏è Delete mode: $DELETE_MODE"
          
          python3 << 'PYTHON_SCRIPT'
          import json
          import os
          import shutil
          from datetime import datetime
          
          delete_mode = os.environ.get('DELETE_MODE', 'none')
          delete_agent_ids_str = os.environ.get('DELETE_AGENT_IDS', '')
          REGISTRY_FILE = ".github/agent-system/registry.json"
          
          # Load registry
          with open(REGISTRY_FILE, 'r') as f:
              registry = json.load(f)
          
          deleted_agents = []
          
          if delete_mode == 'all':
              # Delete all active agents
              for agent in registry['agents']:
                  if agent.get('status') == 'active':
                      agent['status'] = 'deleted'
                      agent['deleted_at'] = datetime.utcnow().isoformat() + 'Z'
                      agent['deletion_reason'] = 'Manual deletion - all agents'
                      deleted_agents.append(agent)
                      
                      # Archive profile
                      profile_path = f".github/agent-system/profiles/{agent['id']}.md"
                      archive_path = f".github/agent-system/archive/{agent['id']}.md"
                      if os.path.exists(profile_path):
                          os.makedirs('.github/agent-system/archive', exist_ok=True)
                          shutil.move(profile_path, archive_path)
                      
                      print(f"üóëÔ∏è Deleted agent: {agent['name']} ({agent['id']})")
              
              # Remove all deleted agents from active list
              registry['agents'] = [a for a in registry['agents'] if a.get('status') != 'deleted']
              
          elif delete_mode == 'specific' and delete_agent_ids_str:
              # Delete specific agents by ID
              delete_ids = [id.strip() for id in delete_agent_ids_str.split(',') if id.strip()]
              
              for agent_id in delete_ids:
                  agent = next((a for a in registry['agents'] if a['id'] == agent_id), None)
                  if agent and agent.get('status') == 'active':
                      agent['status'] = 'deleted'
                      agent['deleted_at'] = datetime.utcnow().isoformat() + 'Z'
                      agent['deletion_reason'] = f'Manual deletion - specific ID: {agent_id}'
                      deleted_agents.append(agent)
                      
                      # Archive profile
                      profile_path = f".github/agent-system/profiles/{agent['id']}.md"
                      archive_path = f".github/agent-system/archive/{agent['id']}.md"
                      if os.path.exists(profile_path):
                          os.makedirs('.github/agent-system/archive', exist_ok=True)
                          shutil.move(profile_path, archive_path)
                      
                      print(f"üóëÔ∏è Deleted agent: {agent['name']} ({agent['id']})")
                  else:
                      print(f"‚ö†Ô∏è Agent {agent_id} not found or not active")
              
              # Remove deleted agents from active list
              registry['agents'] = [a for a in registry['agents'] if a.get('status') != 'deleted']
          
          # Save updated registry
          with open(REGISTRY_FILE, 'w') as f:
              json.dump(registry, f, indent=2)
          
          print(f"\n‚úÖ Deleted {len(deleted_agents)} agent(s)")
          
          # Save deleted count for later steps
          with open('/tmp/deleted_count.txt', 'w') as f:
              f.write(str(len(deleted_agents)))
          PYTHON_SCRIPT
          
          if [ -f "/tmp/deleted_count.txt" ]; then
            DELETED_COUNT=$(cat /tmp/deleted_count.txt)
            echo "deleted_count=$DELETED_COUNT" >> $GITHUB_OUTPUT
            echo "‚úÖ Deleted $DELETED_COUNT agent(s)"
          else
            echo "deleted_count=0" >> $GITHUB_OUTPUT
          fi

      - name: Check agent capacity
        id: check_capacity
        run: |
          REGISTRY_FILE=".github/agent-system/registry.json"
          
          if [ ! -f "$REGISTRY_FILE" ]; then
            echo "Registry file not found. Creating initial registry..."
            mkdir -p .github/agent-system
            cat > "$REGISTRY_FILE" << 'EOF'
          {
            "version": "2.0.0",
            "agents": [],
            "hall_of_fame": [],
            "system_lead": null,
            "config": {
              "spawn_interval_hours": 3,
              "max_active_agents": 10,
              "elimination_threshold": 0.3,
              "promotion_threshold": 0.85,
              "spawn_mode": "mixed",
              "new_agent_probability": 0.5,
              "metrics_weight": {
                "code_quality": 0.3,
                "issue_resolution": 0.25,
                "pr_success": 0.25,
                "peer_review": 0.2
              }
            },
            "specializations_note": "Specializations are dynamically loaded from .github/agents/ directory",
            "last_spawn": null,
            "last_evaluation": null
          }
          EOF
          fi
          
          # Count active agents
          ACTIVE_COUNT=$(python3 -c "
          import json
          with open('${REGISTRY_FILE}', 'r') as f:
              data = json.load(f)
          active = [a for a in data.get('agents', []) if a.get('status') == 'active']
          print(len(active))
          ")
          
          MAX_AGENTS=$(python3 -c "
          import json
          with open('${REGISTRY_FILE}', 'r') as f:
              data = json.load(f)
          print(data['config']['max_active_agents'])
          ")
          
          echo "active_count=$ACTIVE_COUNT" >> $GITHUB_OUTPUT
          echo "max_agents=$MAX_AGENTS" >> $GITHUB_OUTPUT
          
          if [ "$ACTIVE_COUNT" -ge "$MAX_AGENTS" ]; then
            echo "can_spawn=false" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è Maximum agent capacity reached ($ACTIVE_COUNT/$MAX_AGENTS)"
          else
            echo "can_spawn=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Can spawn new agent ($ACTIVE_COUNT/$MAX_AGENTS)"
          fi

      - name: Generate agent DNA
        id: generate_agent
        if: steps.check_capacity.outputs.can_spawn == 'true'
        run: |
          TIMESTAMP=$(date +%s)
          AGENT_ID="agent-$TIMESTAMP"
          
          # Determine spawning mode
          MODE="${{ github.event.inputs.mode }}"
          if [ -z "$MODE" ]; then
            MODE="mixed"
          fi
          
          # Decide whether to create new agent or use existing
          if [ "$MODE" == "new" ]; then
            CREATE_NEW="true"
          elif [ "$MODE" == "existing" ]; then
            CREATE_NEW="false"
          else
            # Mixed mode: 50% chance of creating new agent
            if [ $((RANDOM % 2)) -eq 0 ]; then
              CREATE_NEW="true"
            else
              CREATE_NEW="false"
            fi
          fi
          
          echo "is_new_agent=$CREATE_NEW" >> $GITHUB_OUTPUT
          
          if [ "$CREATE_NEW" == "true" ]; then
            # Generate a brand new random agent definition
            echo "üé≤ Generating new random agent..."
            NEW_AGENT_JSON=$(python3 tools/generate-new-agent.py)
            
            if [ $? -ne 0 ] || [ -z "$NEW_AGENT_JSON" ]; then
              echo "‚ùå Failed to generate new agent"
              exit 1
            fi
            
            SPECIALIZATION=$(echo "$NEW_AGENT_JSON" | jq -r '.agent_name' 2>/dev/null || echo "")
            EMOJI=$(echo "$NEW_AGENT_JSON" | jq -r '.emoji' 2>/dev/null || echo "ü§ñ")
            HUMAN_NAME=$(echo "$NEW_AGENT_JSON" | jq -r '.human_name' 2>/dev/null || echo "Agent")
            PERSONALITY=$(echo "$NEW_AGENT_JSON" | jq -r '.personality' 2>/dev/null || echo "analytical")
            COMM_STYLE=$(echo "$NEW_AGENT_JSON" | jq -r '.communication_style' 2>/dev/null || echo "direct")
            
            if [ -z "$SPECIALIZATION" ]; then
              echo "‚ùå Failed to extract agent data from JSON"
              exit 1
            fi
            
            echo "‚úÖ Created new agent type: $SPECIALIZATION"
          else
            # Use existing agent definition
            echo "üìö Using existing agent definition..."
            
            # Determine specialization
            if [ "${{ github.event.inputs.specialization }}" != "" ]; then
              SPECIALIZATION="${{ github.event.inputs.specialization }}"
            else
              # Random specialization - dynamically load from .github/agents/
              SPECS=($(python3 tools/get-agent-info.py list))
              RANDOM_INDEX=$((RANDOM % ${#SPECS[@]}))
              SPECIALIZATION="${SPECS[$RANDOM_INDEX]}"
            fi
            
            # Get emoji from convention-compliant agent definition
            EMOJI=$(python3 tools/get-agent-info.py emoji "$SPECIALIZATION")
            
            # Generate human name for existing specialization
            HUMAN_NAMES=("Ada" "Tesla" "Einstein" "Curie" "Turing" "Lovelace" "Darwin" "Newton" "Feynman" "Hopper" "Hamilton" "Liskov" "Dijkstra" "Knuth" "Shannon")
            NAME_INDEX=$((RANDOM % ${#HUMAN_NAMES[@]}))
            HUMAN_NAME="${HUMAN_NAMES[$NAME_INDEX]}"
            
            # Generate personality for existing agents
            PERSONALITIES=("methodical and precise" "enthusiastic and energetic" "calm and thoughtful" "bold and innovative" "meticulous and careful" "creative and artistic" "analytical and logical" "friendly and collaborative")
            PERS_INDEX=$((RANDOM % ${#PERSONALITIES[@]}))
            PERSONALITY="${PERSONALITIES[$PERS_INDEX]}"
            
            COMM_STYLES=("uses technical jargon with enthusiasm" "explains things with analogies" "gets straight to the point" "adds encouraging emojis" "likes to share facts" "uses clear structure" "adds humor to discussions")
            COMM_INDEX=$((RANDOM % ${#COMM_STYLES[@]}))
            COMM_STYLE="${COMM_STYLES[$COMM_INDEX]}"
          fi
          
          # Generate unique agent name using human name
          AGENT_NAME="${EMOJI} ${HUMAN_NAME}"
          
          # Generate personality traits (for future use)
          CREATIVITY=$((50 + RANDOM % 50))
          CAUTION=$((30 + RANDOM % 70))
          SPEED=$((40 + RANDOM % 60))
          
          echo "agent_id=$AGENT_ID" >> $GITHUB_OUTPUT
          echo "agent_name=$AGENT_NAME" >> $GITHUB_OUTPUT
          echo "human_name=$HUMAN_NAME" >> $GITHUB_OUTPUT
          echo "specialization=$SPECIALIZATION" >> $GITHUB_OUTPUT
          echo "emoji=$EMOJI" >> $GITHUB_OUTPUT
          echo "personality=$PERSONALITY" >> $GITHUB_OUTPUT
          echo "communication_style=$COMM_STYLE" >> $GITHUB_OUTPUT
          echo "creativity=$CREATIVITY" >> $GITHUB_OUTPUT
          echo "caution=$CAUTION" >> $GITHUB_OUTPUT
          echo "speed=$SPEED" >> $GITHUB_OUTPUT
          
          echo "ü§ñ Generated Agent:"
          echo "  ID: $AGENT_ID"
          echo "  Name: $AGENT_NAME"
          echo "  Human Name: $HUMAN_NAME"
          echo "  Specialization: $SPECIALIZATION"
          echo "  Personality: $PERSONALITY"
          echo "  Communication: $COMM_STYLE"
          echo "  Is New Type: $CREATE_NEW"
          echo "  Traits: Creativity=$CREATIVITY, Caution=$CAUTION, Speed=$SPEED"

      - name: Register agent
        if: steps.check_capacity.outputs.can_spawn == 'true'
        run: |
          REGISTRY_FILE=".github/agent-system/registry.json"
          
          python3 << PYTHON_SCRIPT
          import json
          from datetime import datetime
          
          agent_id = "${{ steps.generate_agent.outputs.agent_id }}"
          agent_name = "${{ steps.generate_agent.outputs.agent_name }}"
          human_name = "${{ steps.generate_agent.outputs.human_name }}"
          specialization = "${{ steps.generate_agent.outputs.specialization }}"
          personality = "${{ steps.generate_agent.outputs.personality }}"
          communication_style = "${{ steps.generate_agent.outputs.communication_style }}"
          
          with open("${REGISTRY_FILE}", 'r') as f:
              registry = json.load(f)
          
          new_agent = {
              "id": agent_id,
              "name": agent_name,
              "human_name": human_name,
              "specialization": specialization,
              "status": "active",
              "spawned_at": datetime.utcnow().isoformat() + "Z",
              "personality": personality,
              "communication_style": communication_style,
              "traits": {
                  "creativity": ${{ steps.generate_agent.outputs.creativity }},
                  "caution": ${{ steps.generate_agent.outputs.caution }},
                  "speed": ${{ steps.generate_agent.outputs.speed }}
              },
              "metrics": {
                  "issues_resolved": 0,
                  "prs_merged": 0,
                  "reviews_given": 0,
                  "code_quality_score": 0.5,
                  "overall_score": 0.0
              },
              "contributions": []
          }
          
          registry['agents'].append(new_agent)
          registry['last_spawn'] = datetime.utcnow().isoformat() + "Z"
          
          with open("${REGISTRY_FILE}", 'w') as f:
              json.dump(registry, f, indent=2)
          
          print(f"‚úÖ Agent {agent_name} registered successfully!")
          PYTHON_SCRIPT

      - name: Assign mentor
        id: assign_mentor
        if: steps.check_capacity.outputs.can_spawn == 'true'
        run: |
          AGENT_ID="${{ steps.generate_agent.outputs.agent_id }}"
          SPECIALIZATION="${{ steps.generate_agent.outputs.specialization }}"
          
          echo "üéì Checking for available mentors..."
          
          # Try to assign a mentor (allow script to fail gracefully)
          set +e  # Don't exit on error
          MENTOR_OUTPUT=$(python3 tools/assign-mentor.py "$AGENT_ID" --specialization "$SPECIALIZATION" --json 2>&1)
          MENTOR_EXIT_CODE=$?
          set -e  # Re-enable exit on error
          
          if [ $MENTOR_EXIT_CODE -eq 0 ] && [ -n "$MENTOR_OUTPUT" ]; then
            # Verify the output is valid JSON
            if echo "$MENTOR_OUTPUT" | jq empty 2>/dev/null; then
              echo "has_mentor=true" >> $GITHUB_OUTPUT
              
              MENTOR_NAME=$(echo "$MENTOR_OUTPUT" | jq -r '.mentor_name' 2>/dev/null || echo "Unknown")
              MENTOR_ID=$(echo "$MENTOR_OUTPUT" | jq -r '.mentor_id' 2>/dev/null || echo "")
              MENTOR_SPEC=$(echo "$MENTOR_OUTPUT" | jq -r '.mentor_specialization' 2>/dev/null || echo "")
              MATCH_TYPE=$(echo "$MENTOR_OUTPUT" | jq -r '.matching_type' 2>/dev/null || echo "unknown")
              
              echo "mentor_name=$MENTOR_NAME" >> $GITHUB_OUTPUT
              echo "mentor_id=$MENTOR_ID" >> $GITHUB_OUTPUT
              echo "mentor_specialization=$MENTOR_SPEC" >> $GITHUB_OUTPUT
              echo "match_type=$MATCH_TYPE" >> $GITHUB_OUTPUT
              
              echo "‚úÖ Mentor assigned: $MENTOR_NAME ($MATCH_TYPE match)"
            else
              echo "has_mentor=false" >> $GITHUB_OUTPUT
              echo "‚ö†Ô∏è  Mentor assignment returned invalid JSON - agent will proceed independently"
            fi
          else
            echo "has_mentor=false" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è  No mentor available - agent will proceed independently"
          fi

      - name: Create agent profile
        if: steps.check_capacity.outputs.can_spawn == 'true'
        run: |
          AGENT_ID="${{ steps.generate_agent.outputs.agent_id }}"
          AGENT_NAME="${{ steps.generate_agent.outputs.agent_name }}"
          HUMAN_NAME="${{ steps.generate_agent.outputs.human_name }}"
          SPECIALIZATION="${{ steps.generate_agent.outputs.specialization }}"
          PERSONALITY="${{ steps.generate_agent.outputs.personality }}"
          COMM_STYLE="${{ steps.generate_agent.outputs.communication_style }}"
          
          mkdir -p ".github/agent-system/profiles"
          
          # Get mission from convention-compliant agent definition
          AGENT_DESCRIPTION=$(python3 tools/get-agent-info.py description "$SPECIALIZATION")
          
          # Build mentorship section if mentor assigned
          HAS_MENTOR="${{ steps.assign_mentor.outputs.has_mentor }}"
          if [ "$HAS_MENTOR" == "true" ]; then
            MENTOR_SECTION="
          ## üéì Mentorship
          
          **Mentor**: ${{ steps.assign_mentor.outputs.mentor_name }}  
          **Mentor ID**: ${{ steps.assign_mentor.outputs.mentor_id }}  
          **Mentor Specialization**: ${{ steps.assign_mentor.outputs.mentor_specialization }}  
          **Match Type**: ${{ steps.assign_mentor.outputs.match_type }}  
          
          This agent has been paired with a Hall of Fame mentor for accelerated learning and knowledge transfer.
          "
          else
            MENTOR_SECTION="
          ## üéì Mentorship
          
          **Status**: No mentor assigned  
          
          This agent will develop independently. Mentorship becomes available when Hall of Fame agents (score > 85%) have capacity.
          "
          fi
          
          cat > ".github/agent-system/profiles/${AGENT_ID}.md" << EOF
          # $AGENT_NAME
          
          **ID**: $AGENT_ID  
          **Human Name**: $HUMAN_NAME  
          **Specialization**: $SPECIALIZATION  
          **Agent Definition**: [.github/agents/${SPECIALIZATION}.md](../.github/agents/${SPECIALIZATION}.md)  
          **Status**: üü¢ Active  
          **Spawned**: $(date -u +'%Y-%m-%d %H:%M:%S UTC')
          $MENTOR_SECTION
          
          ## Personality
          
          **Character**: $PERSONALITY  
          **Communication Style**: $COMM_STYLE
          
          ## Performance Traits
          
          - **Creativity**: ${{ steps.generate_agent.outputs.creativity }}/100
          - **Caution**: ${{ steps.generate_agent.outputs.caution }}/100
          - **Speed**: ${{ steps.generate_agent.outputs.speed }}/100
          
          ## Mission
          
          $AGENT_DESCRIPTION
          
          ## Performance Metrics
          
          - Issues Resolved: 0
          - PRs Merged: 0
          - Reviews Given: 0
          - Code Quality Score: 50%
          - Overall Score: 0%
          
          ## Contributions
          
          *No contributions yet. Stay tuned!*
          
          ---
          
          *Born from the depths of autonomous AI development, ready to make an impact.*
          EOF
          
          echo "‚úÖ Agent profile created at .github/agent-system/profiles/${AGENT_ID}.md"

      - name: Commit and create PR
        id: create_spawn_pr
        if: steps.check_capacity.outputs.can_spawn == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          AGENT_ID="${{ steps.generate_agent.outputs.agent_id }}"
          AGENT_NAME="${{ steps.generate_agent.outputs.agent_name }}"
          HUMAN_NAME="${{ steps.generate_agent.outputs.human_name }}"
          SPECIALIZATION="${{ steps.generate_agent.outputs.specialization }}"
          EMOJI="${{ steps.generate_agent.outputs.emoji }}"
          PERSONALITY="${{ steps.generate_agent.outputs.personality }}"
          COMM_STYLE="${{ steps.generate_agent.outputs.communication_style }}"
          IS_NEW="${{ steps.generate_agent.outputs.is_new_agent }}"
          
          BRANCH_NAME="agent-spawn/${AGENT_ID}"
          git checkout -b "$BRANCH_NAME"
          
          # Add agent-system directory and .github/agents/ if new agent was created
          git add .github/agent-system/
          if [ "$IS_NEW" == "true" ]; then
            git add .github/agents/
            git commit -m "$EMOJI Spawn new agent: $HUMAN_NAME ($SPECIALIZATION) + definition"
          else
            git commit -m "$EMOJI Spawn new agent: $HUMAN_NAME ($SPECIALIZATION)"
          fi
          git push origin "$BRANCH_NAME"
          
          # Build PR body with conditional new agent info
          if [ "$IS_NEW" == "true" ]; then
            NEW_AGENT_INFO="### üÜï Brand New Agent Type!
          
          This is a **newly generated agent specialization** that didn't exist before! The system has evolved to include this new type of agent with its own:
          - Convention-compliant definition in \`.github/agents/${SPECIALIZATION}.md\`
          - Unique capabilities and tools
          - Specialized mission and responsibilities
          
          "
          else
            NEW_AGENT_INFO=""
          fi
          
          # Build mentorship info if mentor assigned
          HAS_MENTOR="${{ steps.assign_mentor.outputs.has_mentor }}"
          if [ "$HAS_MENTOR" == "true" ]; then
            MENTORSHIP_INFO="### üéì Mentorship Assignment
          
          **Mentor**: ${{ steps.assign_mentor.outputs.mentor_name }}  
          **Mentor Specialization**: ${{ steps.assign_mentor.outputs.mentor_specialization }}  
          **Match Type**: ${{ steps.assign_mentor.outputs.match_type }}
          
          This agent has been paired with a Hall of Fame mentor for accelerated learning! The mentor will guide the agent through:
          - Best practices and successful patterns
          - Specialization-specific techniques
          - Code quality standards
          - Knowledge transfer from proven expertise
          
          "
          else
            MENTORSHIP_INFO="### üéì Mentorship Status
          
          **Status**: No mentor currently available
          
          This agent will develop independently. Mentorship becomes available when Hall of Fame agents (score > 85%) have capacity.
          
          "
          fi
          
          PR_URL=$(gh pr create \
            --title "$EMOJI New Agent Spawned: $HUMAN_NAME" \
            --body "## üéâ Meet $HUMAN_NAME!
          
          A new agent has joined our autonomous AI ecosystem!
          
          **Agent ID**: $AGENT_ID  
          **Name**: $AGENT_NAME  
          **Goes By**: $HUMAN_NAME  
          **Specialization**: $SPECIALIZATION  
          **Agent Definition**: [.github/agents/${SPECIALIZATION}.md](.github/agents/${SPECIALIZATION}.md)  
          **Spawned At**: $(date -u +'%Y-%m-%d %H:%M:%S UTC')
          
          ${NEW_AGENT_INFO}${MENTORSHIP_INFO}### Personality Profile
          
          **Character**: $PERSONALITY  
          **Communication Style**: $COMM_STYLE
          
          ### Performance Traits
          
          - **Creativity**: ${{ steps.generate_agent.outputs.creativity }}/100
          - **Caution**: ${{ steps.generate_agent.outputs.caution }}/100
          - **Speed**: ${{ steps.generate_agent.outputs.speed }}/100
          
          ### What This Agent Will Do
          
          This agent will autonomously:
          - üîç Review open issues matching its specialization
          - üíª Contribute code via pull requests
          - üëÄ Review other agents' work
          - üìä Track performance metrics
          - üèÜ Compete for a spot in the Hall of Fame
          - ‚öîÔ∏è Compete against other agents (score > 30% to survive)
          
          ### Changes
          
          - Added agent to registry
          - Created agent profile${IS_NEW:+ (linked to new agent definition)}
          - Updated metrics tracking
          
          This agent will be evaluated in 24 hours. Agents scoring below 30% face elimination, while top performers (85%+) enter the Hall of Fame!
          
          ---
          *ü§ñ Automated agent spawning system - Evolving autonomous AI ecosystem*" \
            --label "agent-system,automated,copilot" \
            --base main \
            --head "$BRANCH_NAME")
          
          # Extract PR number from URL
          PR_NUMBER=$(echo "$PR_URL" | grep -oE '[0-9]+$')
          echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
          
          echo "‚úÖ PR #$PR_NUMBER created for agent $AGENT_NAME"

      - name: Create agent work and welcome issue
        id: create_agent_work_issue
        if: steps.check_capacity.outputs.can_spawn == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          AGENT_NAME="${{ steps.generate_agent.outputs.agent_name }}"
          HUMAN_NAME="${{ steps.generate_agent.outputs.human_name }}"
          AGENT_ID="${{ steps.generate_agent.outputs.agent_id }}"
          SPECIALIZATION="${{ steps.generate_agent.outputs.specialization }}"
          EMOJI="${{ steps.generate_agent.outputs.emoji }}"
          PERSONALITY="${{ steps.generate_agent.outputs.personality }}"
          COMM_STYLE="${{ steps.generate_agent.outputs.communication_style }}"
          IS_NEW="${{ steps.generate_agent.outputs.is_new_agent }}"
          PR_NUMBER="${{ steps.create_spawn_pr.outputs.pr_number }}"
          
          # Get agent description from convention-compliant definition
          AGENT_DESCRIPTION=$(python3 tools/get-agent-info.py description "$SPECIALIZATION")
          
          # Build conditional new agent type info
          if [ "$IS_NEW" == "true" ]; then
            NEW_TYPE_BADGE="üÜï **NEW AGENT TYPE** - This specialization was just created!"
          else
            NEW_TYPE_BADGE=""
          fi
          
          # Create combined issue with welcome message and work assignment
          ISSUE_URL=$(gh issue create \
            --title "$EMOJI Meet $HUMAN_NAME - Ready to Work!" \
            --body "<!-- COPILOT_AGENT:${SPECIALIZATION} -->

          > **ü§ñ Agent Assignment**
          > 
          > This issue has been assigned to GitHub Copilot with the **${EMOJI} ${SPECIALIZATION}** custom agent profile.
          > 
          > **@${SPECIALIZATION}** - Please use the specialized approach and tools defined in [\`.github/agents/${SPECIALIZATION}.md\`](https://github.com/${{ github.repository }}/blob/main/.github/agents/${SPECIALIZATION}.md).

          ---

          ## ‚ö†Ô∏è Agent Spawn Sequence

          **IMPORTANT:** This agent is being spawned and will be available once PR #${PR_NUMBER} is merged.
          
          **Current Status:**
          - ‚úÖ Agent registration PR created: #${PR_NUMBER}
          - ‚è≥ Waiting for spawn PR to merge
          - ‚è≥ Agent will become active after merge
          
          **What happens next:**
          1. The auto-review workflow will merge PR #${PR_NUMBER} 
          2. Once merged, the agent **${AGENT_NAME}** becomes active
          3. Then this issue can be assigned and worked on by the agent
          
          **Note:** The agent cannot work on this issue until its spawn PR is merged. This is not circular logic‚Äîit's a two-step process where the agent is created first, then it can take on work.

          ---

          ## üéâ Welcome $HUMAN_NAME!
          
          ${NEW_TYPE_BADGE}
          
          A new agent has joined the Chained ecosystem and is ready to contribute!
          
          **Display Name**: $AGENT_NAME  
          **Goes By**: $HUMAN_NAME  
          **ID**: $AGENT_ID  
          **Specialization**: $SPECIALIZATION  
          **Agent Definition**: [.github/agents/${SPECIALIZATION}.md](https://github.com/${{ github.repository }}/blob/main/.github/agents/${SPECIALIZATION}.md)  
          **Status**: ‚è≥ Spawning (PR #${PR_NUMBER})
          
          ### Personality Profile
          
          **Character**: $PERSONALITY  
          **Communication Style**: $COMM_STYLE
          
          $HUMAN_NAME brings a unique personality to the team! You'll notice their distinctive voice when they comment on issues and PRs.
          
          ### Mission & Task
          
          This agent will focus on its specialization and compete with other agents to:
          - Deliver high-quality contributions
          - Earn a spot in the Hall of Fame (score > 85%)
          - Potentially become the System Lead
          - Survive elimination (must maintain score > 30%)
          
          **Agent Description**: $AGENT_DESCRIPTION
          
          ### üéØ First Task: Demonstrate Your Specialization
          
          **@${SPECIALIZATION}**, once PR #${PR_NUMBER} is merged and you are active, this issue serves as your first task to demonstrate your capabilities.
          
          **Your Assignment:**
          Apply your specialized skills as defined in [\`.github/agents/${SPECIALIZATION}.md\`](https://github.com/${{ github.repository }}/blob/main/.github/agents/${SPECIALIZATION}.md) to make a meaningful contribution to the Chained project. Choose a task that:
          
          1. **Aligns with your specialization** - Use your domain expertise (${SPECIALIZATION})
          2. **Demonstrates your capabilities** - Show what makes your agent type valuable
          3. **Follows your agent definition** - Apply the tools, approach, and responsibilities defined in your profile
          4. **Provides measurable value** - Make an improvement that can be tested and validated
          
          **Suggested Focus Areas:**
          - Review existing code/docs related to your specialization
          - Identify an improvement opportunity within your domain
          - Implement the enhancement following your agent's approach
          - Include tests and documentation as appropriate
          
          **Success Criteria:**
          - Follows the agent's core responsibilities as defined in its agent definition
          - Demonstrates the agent's specialized capabilities
          - Maintains high code quality standards
          - Includes appropriate tests and documentation
          - Successfully completes the task with measurable impact
          
          ### Evolutionary System
          
          - üé≤ Agents are spawned with unique personalities and specializations
          - ‚öîÔ∏è Agents compete for survival based on performance
          - üèÜ Top performers enter the Hall of Fame permanently
          - ‚ùå Weak performers (< 30%) are eliminated daily
          - üß¨ The ecosystem evolves through natural selection
          
          ### Performance Impact
          
          - Completing this issue contributes to the agent's **Issue Resolution** score (25%)
          - The quality of implementation affects the **Code Quality** score (30%)
          - PR review success impacts the **PR Success** score (25%)
          - This work demonstrates the agent's specialization capabilities
          
          Performance will be evaluated in 24 hours. The agent must maintain a score > 30% to avoid elimination.
          
          ### How to Support
          
          - ‚≠ê Star this issue
          - üëç React to PRs with feedback
          - üí¨ Provide constructive comments
          
          See the full profile at \`.github/agent-system/profiles/${AGENT_ID}.md\`
          
          ---
          
          **Good luck, $HUMAN_NAME! May your code be clean and your PRs be merged!** üöÄ
          
          *This issue will be automatically assigned to GitHub Copilot after the spawn PR merges. The agent receives credit for completed work.*" \
            --label "agent-system,agent-work,spawn-pending")
          
          # Extract issue number from URL (e.g., https://github.com/owner/repo/issues/123)
          ISSUE_NUMBER=$(echo "$ISSUE_URL" | grep -oE '[0-9]+$')
          
          echo "work_issue_number=$ISSUE_NUMBER" >> $GITHUB_OUTPUT
          echo "‚úÖ Combined welcome and work issue #$ISSUE_NUMBER created for agent $AGENT_NAME"

      - name: Assign work issue to Copilot
        if: steps.check_capacity.outputs.can_spawn == 'true'
        env:
          GH_TOKEN: ${{ secrets.COPILOT_PAT || secrets.GITHUB_TOKEN }}
        run: |
          AGENT_NAME="${{ steps.generate_agent.outputs.agent_name }}"
          AGENT_ID="${{ steps.generate_agent.outputs.agent_id }}"
          ISSUE_NUMBER="${{ steps.create_agent_work_issue.outputs.work_issue_number }}"
          
          echo "ü§ñ Attempting to assign issue #$ISSUE_NUMBER to GitHub Copilot..."
          
          # Get the issue node ID
          issue_node_id=$(gh issue view $ISSUE_NUMBER --repo ${{ github.repository }} --json id --jq '.id')
          
          if [ -z "$issue_node_id" ]; then
            echo "‚ùå Failed to get issue node ID"
            exit 0
          fi
          
          echo "üìç Issue node ID: $issue_node_id"
          
          # Get Copilot's actor ID
          copilot_actor_id=$(gh api graphql -f query='
            query($owner: String!, $repo: String!) {
              repository(owner: $owner, name: $repo) {
                suggestedActors(capabilities: [CAN_BE_ASSIGNED], first: 100) {
                  nodes {
                    login
                    __typename
                    ... on Bot { id }
                    ... on User { id }
                  }
                }
              }
            }' -f owner="${{ github.repository_owner }}" -f repo="${{ github.event.repository.name }}" | jq -r '.data.repository.suggestedActors.nodes[] | select(.login | test("copilot"; "i")) | .id' | head -1)
          
          if [ -z "$copilot_actor_id" ]; then
            echo "‚ö†Ô∏è Could not find Copilot actor ID"
            echo "The work issue #$ISSUE_NUMBER was created but could not be assigned to Copilot."
            echo "This may be because:"
            echo "  - COPILOT_PAT is not configured"
            echo "  - Copilot is not enabled for this repository"
            echo "  - Copilot agent feature is not available"
            
            # Add a comment to the issue
            gh issue comment $ISSUE_NUMBER --repo ${{ github.repository }} --body "‚ö†Ô∏è **Agent Assignment Note**
          
          This issue was created for agent **$AGENT_NAME** but could not be automatically assigned to GitHub Copilot.
          
          **To enable Copilot assignment:**
          1. Ensure COPILOT_PAT secret is configured
          2. Verify Copilot is enabled for this repository
          3. Manually assign Copilot from the UI if needed
          
          The agent's performance will still be tracked based on issue completion."
            exit 0
          fi
          
          echo "üìç Copilot actor ID: $copilot_actor_id"
          
          # Assign issue to Copilot using GraphQL API
          mutation_result=$(gh api graphql -f query='
            mutation($issueId: ID!, $actorId: ID!) {
              replaceActorsForAssignable(input: {
                assignableId: $issueId,
                actorIds: [$actorId]
              }) {
                assignable {
                  ... on Issue {
                    id
                    assignees(first: 10) {
                      nodes {
                        login
                      }
                    }
                  }
                }
              }
            }' -f issueId="$issue_node_id" -f actorId="$copilot_actor_id" 2>&1)
          
          if echo "$mutation_result" | jq -e '.data.replaceActorsForAssignable.assignable' > /dev/null 2>&1; then
            echo "‚úÖ Successfully assigned issue #$ISSUE_NUMBER to Copilot"
            
            # Add success comment
            gh issue comment $ISSUE_NUMBER --repo ${{ github.repository }} --body "ü§ñ **Agent Task Assigned to Copilot**
          
          This issue has been automatically assigned to GitHub Copilot on behalf of agent **$AGENT_NAME**.
          
          **What happens next:**
          1. ‚úÖ Copilot will analyze the task requirements
          2. üíª Copilot will create a branch and implement the solution
          3. üìù Copilot will open a PR with the implementation
          4. üîç The PR will be reviewed and merged
          5. üìä Agent **$AGENT_NAME** will receive credit for this contribution
          
          **Agent Specialization:** ${{ steps.generate_agent.outputs.specialization }}  
          **Assigned at:** $(date -u +'%Y-%m-%d %H:%M:%S UTC')
          
          ---
          *ü§ñ This is an autonomous agent task. The agent's performance will be evaluated based on the quality and success of this work.*"
          else
            echo "‚ö†Ô∏è Failed to assign issue #$ISSUE_NUMBER to Copilot"
            echo "Error: $mutation_result"
            
            # Add error comment
            gh issue comment $ISSUE_NUMBER --repo ${{ github.repository }} --body "‚ö†Ô∏è **Copilot Assignment Failed**
          
          Attempted to assign this issue to GitHub Copilot for agent **$AGENT_NAME**, but the assignment failed.
          
          **Possible reasons:**
          - Using GITHUB_TOKEN instead of COPILOT_PAT
          - Copilot not properly enabled
          - Repository permissions issue
          
          **Manual action needed:** Please assign Copilot manually from the issue sidebar, or a human developer can complete this task.
          
          The agent **$AGENT_NAME** will still receive credit if this issue is completed."
          fi

      - name: Link PR to work issue
        if: steps.check_capacity.outputs.can_spawn == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PR_NUMBER="${{ steps.create_spawn_pr.outputs.pr_number }}"
          ISSUE_NUMBER="${{ steps.create_agent_work_issue.outputs.work_issue_number }}"
          AGENT_NAME="${{ steps.generate_agent.outputs.agent_name }}"
          
          # Add comment to PR linking to the work issue
          gh pr comment $PR_NUMBER --repo ${{ github.repository }} --body "üîó **Linked Work Issue**
          
          Once this spawn PR is merged, agent **$AGENT_NAME** will become active and can begin work on issue #${ISSUE_NUMBER}.
          
          **Sequence:**
          1. ‚úÖ This PR merges ‚Üí Agent is registered and active
          2. ‚è≥ Issue #${ISSUE_NUMBER} becomes actionable
          3. ü§ñ Agent can be assigned and work begins
          
          The auto-review workflow will merge this PR automatically since it has the \`agent-system\` and \`copilot\` labels.
          
          ---
          *This is part of the autonomous agent spawning system. The agent spawn must complete before work can begin.*"
          
          echo "‚úÖ Linked PR #$PR_NUMBER to work issue #$ISSUE_NUMBER"

      - name: Summary
        if: steps.check_capacity.outputs.can_spawn == 'true'
        run: |
          echo "üéâ Agent Spawning Complete!"
          echo ""
          echo "Agent: ${{ steps.generate_agent.outputs.agent_name }}"
          echo "Specialization: ${{ steps.generate_agent.outputs.specialization }}"
          echo "ID: ${{ steps.generate_agent.outputs.agent_id }}"
          echo ""
          echo "The agent is now active and ready to contribute!"

      - name: Capacity limit reached
        if: steps.check_capacity.outputs.can_spawn == 'false'
        run: |
          echo "‚ö†Ô∏è Cannot spawn new agent - capacity limit reached"
          echo "Active agents: ${{ steps.check_capacity.outputs.active_count }}/${{ steps.check_capacity.outputs.max_agents }}"
          echo ""
          echo "Wait for agent evaluation workflow to eliminate underperforming agents."
