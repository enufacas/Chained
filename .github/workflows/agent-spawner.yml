name: "Agent System: Spawner"

on:
  schedule:
    # Run every 3 hours
    - cron: '0 */3 * * *'
  workflow_dispatch:
    inputs:
      mode:
        description: 'Spawning mode'
        required: false
        type: choice
        default: 'mixed'
        options:
          - mixed  # 50% existing, 50% new random agents
          - existing  # Only use existing agent definitions
          - new  # Always create new random agents
      specialization:
        description: 'Force specific specialization (leave empty for random, only works with existing mode)'
        required: false
        type: string
      delete_mode:
        description: 'Delete agents before spawning'
        required: false
        type: choice
        default: 'none'
        options:
          - none  # Don't delete any agents
          - all  # Delete all active agents and respawn
          - specific  # Delete specific agent IDs (provide in delete_agent_ids)
      delete_agent_ids:
        description: 'Comma-separated agent IDs to delete (only used with delete_mode=specific, e.g., "agent-123,agent-456")'
        required: false
        type: string
      respawn_count:
        description: 'Number of agents to spawn after deletion (default: 1, max: 5)'
        required: false
        type: number
        default: 1


permissions:
  contents: write
  issues: write
  pull-requests: write

jobs:
  spawn-agent:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Configure git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Ensure agent system labels exist
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "üè∑Ô∏è Checking and creating agent system labels..."
          
          # Function to create label if it doesn't exist
          create_label_if_missing() {
            local name="$1"
            local color="$2"
            local description="$3"
            
            # Check if label exists by checking for the exact name with word boundary
            if gh label list --repo ${{ github.repository }} | grep -q "^${name}[[:space:]]"; then
              echo "‚úì Label '$name' already exists, skipping creation"
            else
              # Try to create the label, will fail if it exists
              if gh label create "$name" --color "$color" --description "$description" --repo ${{ github.repository }} 2>&1; then
                echo "‚úÖ Created label '$name'"
              else
                echo "‚úì Label '$name' already exists (detected during creation attempt)"
              fi
            fi
          }
          
          # Create all agent system labels
          create_label_if_missing "agent-system" "7057ff" "Agent ecosystem activity"
          create_label_if_missing "agent-work" "0e8a16" "Work assigned to agents"
          create_label_if_missing "spawn-pending" "d4c5f9" "Waiting for agent spawn PR to merge"
          create_label_if_missing "announcement" "0075ca" "Agent announcements"
          create_label_if_missing "evaluation" "e4e669" "Agent evaluations"
          create_label_if_missing "automated" "ededed" "Auto-generated content"
          create_label_if_missing "copilot" "8b5cf6" "Copilot-related tasks"
          
          echo "‚úÖ All agent system labels verified"

      - name: Delete agents if requested
        id: delete_agents
        if: github.event.inputs.delete_mode != 'none' && github.event.inputs.delete_mode != ''
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          DELETE_MODE="${{ github.event.inputs.delete_mode }}"
          DELETE_AGENT_IDS="${{ github.event.inputs.delete_agent_ids }}"
          
          echo "üóëÔ∏è Delete mode: $DELETE_MODE"
          
          python3 << 'PYTHON_SCRIPT'
          import json
          import os
          import sys
          import shutil
          from datetime import datetime
          from pathlib import Path
          
          # Add tools directory to path
          sys.path.insert(0, 'tools')
          from registry_manager import RegistryManager
          
          delete_mode = os.environ.get('DELETE_MODE', 'none')
          delete_agent_ids_str = os.environ.get('DELETE_AGENT_IDS', '')
          
          # Use registry manager
          registry = RegistryManager()
          deleted_agents = []
          
          if delete_mode == 'all':
              # Delete all active agents
              agents = registry.list_agents(status='active')
              for agent in agents:
                  agent_id = agent['id']
                  
                  # Archive profile
                  profile_path = Path(f".github/agent-system/profiles/{agent_id}.md")
                  archive_path = Path(f".github/agent-system/archive/{agent_id}.md")
                  if profile_path.exists():
                      archive_path.parent.mkdir(parents=True, exist_ok=True)
                      shutil.move(str(profile_path), str(archive_path))
                  
                  # Delete from registry
                  registry.delete_agent(agent_id)
                  deleted_agents.append(agent)
                  print(f"üóëÔ∏è Deleted agent: {agent['name']} ({agent_id})")
              
          elif delete_mode == 'specific' and delete_agent_ids_str:
              # Delete specific agents by ID
              delete_ids = [id.strip() for id in delete_agent_ids_str.split(',') if id.strip()]
              
              for agent_id in delete_ids:
                  agent = registry.get_agent(agent_id)
                  if agent and agent.get('status') == 'active':
                      # Archive profile
                      profile_path = Path(f".github/agent-system/profiles/{agent_id}.md")
                      archive_path = Path(f".github/agent-system/archive/{agent_id}.md")
                      if profile_path.exists():
                          archive_path.parent.mkdir(parents=True, exist_ok=True)
                          shutil.move(str(profile_path), str(archive_path))
                      
                      # Delete from registry
                      registry.delete_agent(agent_id)
                      deleted_agents.append(agent)
                      print(f"üóëÔ∏è Deleted agent: {agent['name']} ({agent_id})")
                  else:
                      print(f"‚ö†Ô∏è Agent {agent_id} not found or not active")
          
          print(f"\n‚úÖ Deleted {len(deleted_agents)} agent(s)")
          
          # Save deleted count for later steps
          with open('/tmp/deleted_count.txt', 'w') as f:
              f.write(str(len(deleted_agents)))
          PYTHON_SCRIPT
          
          if [ -f "/tmp/deleted_count.txt" ]; then
            DELETED_COUNT=$(cat /tmp/deleted_count.txt)
            echo "deleted_count=$DELETED_COUNT" >> $GITHUB_OUTPUT
            echo "‚úÖ Deleted $DELETED_COUNT agent(s)"
          else
            echo "deleted_count=0" >> $GITHUB_OUTPUT
          fi

      - name: Check agent capacity
        id: check_capacity
        run: |
          # Count active agents using new registry manager
          ACTIVE_COUNT=$(python3 tools/list_agents_from_registry.py --status active --format count)
          
          MAX_AGENTS=$(python3 -c "
          import sys
          sys.path.insert(0, 'tools')
          from registry_manager import RegistryManager
          registry = RegistryManager()
          config = registry.get_config()
          print(config['max_active_agents'])
          ")
          
          echo "active_count=$ACTIVE_COUNT" >> $GITHUB_OUTPUT
          echo "max_agents=$MAX_AGENTS" >> $GITHUB_OUTPUT
          
          if [ "$ACTIVE_COUNT" -ge "$MAX_AGENTS" ]; then
            echo "can_spawn=false" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è Maximum agent capacity reached ($ACTIVE_COUNT/$MAX_AGENTS)"
          else
            echo "can_spawn=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Can spawn new agent ($ACTIVE_COUNT/$MAX_AGENTS)"
          fi

      - name: Generate agent DNA
        id: generate_agent
        if: steps.check_capacity.outputs.can_spawn == 'true'
        run: |
          # Use nanosecond precision + random component to avoid collisions
          TIMESTAMP=$(date +%s%N)
          RANDOM_SUFFIX=$((RANDOM * RANDOM % 100000))
          AGENT_ID="agent-${TIMESTAMP}-${RANDOM_SUFFIX}"
          
          # Determine spawning mode
          MODE="${{ github.event.inputs.mode }}"
          if [ -z "$MODE" ]; then
            MODE="mixed"
          fi
          
          # Decide whether to create new agent or use existing
          if [ "$MODE" == "new" ]; then
            CREATE_NEW="true"
          elif [ "$MODE" == "existing" ]; then
            CREATE_NEW="false"
          else
            # Mixed mode: 50% chance of creating new agent
            if [ $((RANDOM % 2)) -eq 0 ]; then
              CREATE_NEW="true"
            else
              CREATE_NEW="false"
            fi
          fi
          
          echo "is_new_agent=$CREATE_NEW" >> $GITHUB_OUTPUT
          
          if [ "$CREATE_NEW" == "true" ]; then
            # Generate a brand new random agent definition
            echo "üé≤ Generating new random agent..."
            NEW_AGENT_JSON=$(python3 tools/generate-new-agent.py)
            
            if [ $? -ne 0 ] || [ -z "$NEW_AGENT_JSON" ]; then
              echo "‚ùå Failed to generate new agent"
              exit 1
            fi
            
            SPECIALIZATION=$(echo "$NEW_AGENT_JSON" | jq -r '.agent_name' 2>/dev/null || echo "")
            EMOJI=$(echo "$NEW_AGENT_JSON" | jq -r '.emoji' 2>/dev/null || echo "ü§ñ")
            HUMAN_NAME=$(echo "$NEW_AGENT_JSON" | jq -r '.human_name' 2>/dev/null || echo "Agent")
            PERSONALITY=$(echo "$NEW_AGENT_JSON" | jq -r '.personality' 2>/dev/null || echo "analytical")
            COMM_STYLE=$(echo "$NEW_AGENT_JSON" | jq -r '.communication_style' 2>/dev/null || echo "direct")
            
            if [ -z "$SPECIALIZATION" ]; then
              echo "‚ùå Failed to extract agent data from JSON"
              exit 1
            fi
            
            echo "‚úÖ Created new agent type: $SPECIALIZATION"
          else
            # Use existing agent definition
            echo "üìö Using existing agent definition..."
            
            # Determine specialization
            if [ "${{ github.event.inputs.specialization }}" != "" ]; then
              SPECIALIZATION="${{ github.event.inputs.specialization }}"
            else
              # Random specialization - dynamically load from .github/agents/
              SPECS=($(python3 tools/get-agent-info.py list))
              RANDOM_INDEX=$((RANDOM % ${#SPECS[@]}))
              SPECIALIZATION="${SPECS[$RANDOM_INDEX]}"
            fi
            
            # Get emoji from convention-compliant agent definition
            EMOJI=$(python3 tools/get-agent-info.py emoji "$SPECIALIZATION")
            
            # Generate unique human name for existing specialization
            # Use helper script to get available names (not used by active agents)
            HUMAN_NAME=$(python3 tools/get-available-human-names.py --format random --with-fallback)
            if [ -z "$HUMAN_NAME" ]; then
              echo "‚ùå Failed to generate unique human name"
              exit 1
            fi
            
            # Generate personality for existing agents
            PERSONALITIES=("methodical and precise" "enthusiastic and energetic" "calm and thoughtful" "bold and innovative" "meticulous and careful" "creative and artistic" "analytical and logical" "friendly and collaborative")
            PERS_INDEX=$((RANDOM % ${#PERSONALITIES[@]}))
            PERSONALITY="${PERSONALITIES[$PERS_INDEX]}"
            
            COMM_STYLES=("uses technical jargon with enthusiasm" "explains things with analogies" "gets straight to the point" "adds encouraging emojis" "likes to share facts" "uses clear structure" "adds humor to discussions")
            COMM_INDEX=$((RANDOM % ${#COMM_STYLES[@]}))
            COMM_STYLE="${COMM_STYLES[$COMM_INDEX]}"
          fi
          
          # Generate unique agent name using human name
          AGENT_NAME="${EMOJI} ${HUMAN_NAME}"
          
          # Generate personality traits (for future use)
          CREATIVITY=$((50 + RANDOM % 50))
          CAUTION=$((30 + RANDOM % 70))
          SPEED=$((40 + RANDOM % 60))
          
          echo "agent_id=$AGENT_ID" >> $GITHUB_OUTPUT
          echo "agent_name=$AGENT_NAME" >> $GITHUB_OUTPUT
          echo "human_name=$HUMAN_NAME" >> $GITHUB_OUTPUT
          echo "specialization=$SPECIALIZATION" >> $GITHUB_OUTPUT
          echo "emoji=$EMOJI" >> $GITHUB_OUTPUT
          echo "personality=$PERSONALITY" >> $GITHUB_OUTPUT
          echo "communication_style=$COMM_STYLE" >> $GITHUB_OUTPUT
          echo "creativity=$CREATIVITY" >> $GITHUB_OUTPUT
          echo "caution=$CAUTION" >> $GITHUB_OUTPUT
          echo "speed=$SPEED" >> $GITHUB_OUTPUT
          
          echo "ü§ñ Generated Agent:"
          echo "  ID: $AGENT_ID"
          echo "  Name: $AGENT_NAME"
          echo "  Human Name: $HUMAN_NAME"
          echo "  Specialization: $SPECIALIZATION"
          echo "  Personality: $PERSONALITY"
          echo "  Communication: $COMM_STYLE"
          echo "  Is New Type: $CREATE_NEW"
          echo "  Traits: Creativity=$CREATIVITY, Caution=$CAUTION, Speed=$SPEED"

      - name: Verify agent ID uniqueness
        if: steps.check_capacity.outputs.can_spawn == 'true'
        run: |
          AGENT_ID="${{ steps.generate_agent.outputs.agent_id }}"
          
          # Check if agent ID already exists in registry
          if python3 -c "
          import sys
          sys.path.insert(0, 'tools')
          from registry_manager import RegistryManager
          registry = RegistryManager()
          agent = registry.get_agent('$AGENT_ID')
          sys.exit(0 if agent is None else 1)
          "; then
            echo "‚úÖ Agent ID is unique: $AGENT_ID"
          else
            echo "‚ùå ERROR: Agent ID already exists in registry: $AGENT_ID"
            echo "This should not happen with improved random generation!"
            exit 1
          fi

      - name: Register agent
        if: steps.check_capacity.outputs.can_spawn == 'true'
        run: |
          # Create agent data JSON
          cat > /tmp/new_agent.json << EOF
          {
            "id": "${{ steps.generate_agent.outputs.agent_id }}",
            "name": "${{ steps.generate_agent.outputs.agent_name }}",
            "human_name": "${{ steps.generate_agent.outputs.human_name }}",
            "specialization": "${{ steps.generate_agent.outputs.specialization }}",
            "status": "active",
            "spawned_at": "$(date -u +"%Y-%m-%dT%H:%M:%S.%6NZ")",
            "personality": "${{ steps.generate_agent.outputs.personality }}",
            "communication_style": "${{ steps.generate_agent.outputs.communication_style }}",
            "traits": {
              "creativity": ${{ steps.generate_agent.outputs.creativity }},
              "caution": ${{ steps.generate_agent.outputs.caution }},
              "speed": ${{ steps.generate_agent.outputs.speed }}
            },
            "metrics": {
              "issues_resolved": 0,
              "prs_merged": 0,
              "reviews_given": 0,
              "code_quality_score": 0.5,
              "overall_score": 0.0
            },
            "contributions": []
          }
          EOF
          
          # Add agent to registry using helper script
          python3 tools/add_agent_to_registry.py /tmp/new_agent.json

      - name: Assign mentor
        id: assign_mentor
        if: steps.check_capacity.outputs.can_spawn == 'true'
        run: |
          set +e  # Disable exit on error for this step to handle mentor unavailability gracefully
          AGENT_ID="${{ steps.generate_agent.outputs.agent_id }}"
          SPECIALIZATION="${{ steps.generate_agent.outputs.specialization }}"
          
          echo "üéì Checking for available mentors..."
          
          # Try to assign a mentor (allow script to fail gracefully)
          set +e  # Don't exit on error
          MENTOR_OUTPUT=$(python3 tools/assign-mentor.py "$AGENT_ID" --specialization "$SPECIALIZATION" --json 2>&1)
          MENTOR_EXIT_CODE=$?
          set -e  # Re-enable exit on error
          
          if [ $MENTOR_EXIT_CODE -eq 0 ] && [ -n "$MENTOR_OUTPUT" ]; then
            # Verify the output is valid JSON
            if echo "$MENTOR_OUTPUT" | jq empty 2>/dev/null; then
              echo "has_mentor=true" >> $GITHUB_OUTPUT
              
              MENTOR_NAME=$(echo "$MENTOR_OUTPUT" | jq -r '.mentor_name' 2>/dev/null || echo "Unknown")
              MENTOR_ID=$(echo "$MENTOR_OUTPUT" | jq -r '.mentor_id' 2>/dev/null || echo "")
              MENTOR_SPEC=$(echo "$MENTOR_OUTPUT" | jq -r '.mentor_specialization' 2>/dev/null || echo "")
              MATCH_TYPE=$(echo "$MENTOR_OUTPUT" | jq -r '.matching_type' 2>/dev/null || echo "unknown")
              
              echo "mentor_name=$MENTOR_NAME" >> $GITHUB_OUTPUT
              echo "mentor_id=$MENTOR_ID" >> $GITHUB_OUTPUT
              echo "mentor_specialization=$MENTOR_SPEC" >> $GITHUB_OUTPUT
              echo "match_type=$MATCH_TYPE" >> $GITHUB_OUTPUT
              
              echo "‚úÖ Mentor assigned: $MENTOR_NAME ($MATCH_TYPE match)"
            else
              echo "has_mentor=false" >> $GITHUB_OUTPUT
              echo "‚ö†Ô∏è  Mentor assignment returned invalid JSON - agent will proceed independently"
            fi
          else
            echo "has_mentor=false" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è  No mentor available - agent will proceed independently"
          fi

      - name: Create agent profile
        if: steps.check_capacity.outputs.can_spawn == 'true'
        run: |
          AGENT_ID="${{ steps.generate_agent.outputs.agent_id }}"
          AGENT_NAME="${{ steps.generate_agent.outputs.agent_name }}"
          HUMAN_NAME="${{ steps.generate_agent.outputs.human_name }}"
          SPECIALIZATION="${{ steps.generate_agent.outputs.specialization }}"
          PERSONALITY="${{ steps.generate_agent.outputs.personality }}"
          COMM_STYLE="${{ steps.generate_agent.outputs.communication_style }}"
          
          mkdir -p ".github/agent-system/profiles"
          
          # Get mission from convention-compliant agent definition
          AGENT_DESCRIPTION=$(python3 tools/get-agent-info.py description "$SPECIALIZATION")
          
          # Build mentorship section if mentor assigned
          HAS_MENTOR="${{ steps.assign_mentor.outputs.has_mentor }}"
          if [ "$HAS_MENTOR" == "true" ]; then
            MENTOR_SECTION="
          ## üéì Mentorship
          
          **Mentor**: ${{ steps.assign_mentor.outputs.mentor_name }}  
          **Mentor ID**: ${{ steps.assign_mentor.outputs.mentor_id }}  
          **Mentor Specialization**: ${{ steps.assign_mentor.outputs.mentor_specialization }}  
          **Match Type**: ${{ steps.assign_mentor.outputs.match_type }}  
          
          This agent has been paired with a Hall of Fame mentor for accelerated learning and knowledge transfer.
          "
          else
            MENTOR_SECTION="
          ## üéì Mentorship
          
          **Status**: No mentor assigned  
          
          This agent will develop independently. Mentorship becomes available when Hall of Fame agents (score > 85%) have capacity.
          "
          fi
          
          cat > ".github/agent-system/profiles/${AGENT_ID}.md" << EOF
          # $AGENT_NAME
          
          **ID**: $AGENT_ID  
          **Human Name**: $HUMAN_NAME  
          **Specialization**: $SPECIALIZATION  
          **Agent Definition**: [.github/agents/${SPECIALIZATION}.md](../.github/agents/${SPECIALIZATION}.md)  
          **Status**: üü¢ Active  
          **Spawned**: $(date -u +'%Y-%m-%d %H:%M:%S UTC')
          $MENTOR_SECTION
          
          ## Personality
          
          **Character**: $PERSONALITY  
          **Communication Style**: $COMM_STYLE
          
          ## Performance Traits
          
          - **Creativity**: ${{ steps.generate_agent.outputs.creativity }}/100
          - **Caution**: ${{ steps.generate_agent.outputs.caution }}/100
          - **Speed**: ${{ steps.generate_agent.outputs.speed }}/100
          
          ## Mission
          
          $AGENT_DESCRIPTION
          
          ## Performance Metrics
          
          - Issues Resolved: 0
          - PRs Merged: 0
          - Reviews Given: 0
          - Code Quality Score: 50%
          - üé® Creativity Score: 50%
          - Overall Score: 0%
          
          ## Contributions
          
          *No contributions yet. Stay tuned!*
          
          ---
          
          *Born from the depths of autonomous AI development, ready to make an impact.*
          EOF
          
          echo "‚úÖ Agent profile created at .github/agent-system/profiles/${AGENT_ID}.md"

      - name: Commit and create PR
        id: create_spawn_pr
        if: steps.check_capacity.outputs.can_spawn == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          AGENT_ID="${{ steps.generate_agent.outputs.agent_id }}"
          AGENT_NAME="${{ steps.generate_agent.outputs.agent_name }}"
          HUMAN_NAME="${{ steps.generate_agent.outputs.human_name }}"
          SPECIALIZATION="${{ steps.generate_agent.outputs.specialization }}"
          EMOJI="${{ steps.generate_agent.outputs.emoji }}"
          PERSONALITY="${{ steps.generate_agent.outputs.personality }}"
          COMM_STYLE="${{ steps.generate_agent.outputs.communication_style }}"
          IS_NEW="${{ steps.generate_agent.outputs.is_new_agent }}"
          
          BRANCH_NAME="agent-spawn/${AGENT_ID}"
          git checkout -b "$BRANCH_NAME"
          
          # Add agent-system directory and .github/agents/ if new agent was created
          git add .github/agent-system/
          if [ "$IS_NEW" == "true" ]; then
            git add .github/agents/
            git commit -m "$EMOJI Spawn new agent: $HUMAN_NAME ($SPECIALIZATION) + definition"
          else
            git commit -m "$EMOJI Spawn new agent: $HUMAN_NAME ($SPECIALIZATION)"
          fi
          git push origin "$BRANCH_NAME"
          
          # Build PR body with conditional new agent info
          if [ "$IS_NEW" == "true" ]; then
            NEW_AGENT_INFO="### üÜï Brand New Agent Type!
          
          This is a **newly generated agent specialization** that didn't exist before! The system has evolved to include this new type of agent with its own:
          - Convention-compliant definition in \`.github/agents/${SPECIALIZATION}.md\`
          - Unique capabilities and tools
          - Specialized mission and responsibilities
          
          "
          else
            NEW_AGENT_INFO=""
          fi
          
          # Build mentorship info if mentor assigned
          HAS_MENTOR="${{ steps.assign_mentor.outputs.has_mentor }}"
          if [ "$HAS_MENTOR" == "true" ]; then
            MENTORSHIP_INFO="### üéì Mentorship Assignment
          
          **Mentor**: ${{ steps.assign_mentor.outputs.mentor_name }}  
          **Mentor Specialization**: ${{ steps.assign_mentor.outputs.mentor_specialization }}  
          **Match Type**: ${{ steps.assign_mentor.outputs.match_type }}
          
          This agent has been paired with a Hall of Fame mentor for accelerated learning! The mentor will guide the agent through:
          - Best practices and successful patterns
          - Specialization-specific techniques
          - Code quality standards
          - Knowledge transfer from proven expertise
          
          "
          else
            MENTORSHIP_INFO="### üéì Mentorship Status
          
          **Status**: No mentor currently available
          
          This agent will develop independently. Mentorship becomes available when Hall of Fame agents (score > 85%) have capacity.
          
          "
          fi
          
          PR_URL=$(gh pr create \
            --title "$EMOJI New Agent Spawned: $HUMAN_NAME" \
            --body "## üéâ Meet $HUMAN_NAME!
          
          A new agent has joined our autonomous AI ecosystem!
          
          **Agent ID**: $AGENT_ID  
          **Name**: $AGENT_NAME  
          **Goes By**: $HUMAN_NAME  
          **Specialization**: $SPECIALIZATION  
          **Agent Definition**: [.github/agents/${SPECIALIZATION}.md](.github/agents/${SPECIALIZATION}.md)  
          **Spawned At**: $(date -u +'%Y-%m-%d %H:%M:%S UTC')
          
          ${NEW_AGENT_INFO}${MENTORSHIP_INFO}### Personality Profile
          
          **Character**: $PERSONALITY  
          **Communication Style**: $COMM_STYLE
          
          ### Performance Traits
          
          - **Creativity**: ${{ steps.generate_agent.outputs.creativity }}/100
          - **Caution**: ${{ steps.generate_agent.outputs.caution }}/100
          - **Speed**: ${{ steps.generate_agent.outputs.speed }}/100
          
          ### What This Agent Will Do
          
          This agent will autonomously:
          - üîç Review open issues matching its specialization
          - üíª Contribute code via pull requests
          - üëÄ Review other agents' work
          - üìä Track performance metrics
          - üèÜ Compete for a spot in the Hall of Fame
          - ‚öîÔ∏è Compete against other agents (score > 30% to survive)
          
          ### Changes
          
          - Added agent to registry
          - Created agent profile${IS_NEW:+ (linked to new agent definition)}
          - Updated metrics tracking
          
          This agent will be evaluated in 24 hours. Agents scoring below 30% face elimination, while top performers (85%+) enter the Hall of Fame!
          
          ---
          *ü§ñ Automated agent spawning system - Evolving autonomous AI ecosystem*" \
            --label "agent-system,automated,copilot" \
            --base main \
            --head "$BRANCH_NAME") || {
            echo "‚ö†Ô∏è PR creation with labels failed, retrying without labels..."
            PR_URL=$(gh pr create \
              --title "$EMOJI New Agent Spawned: $HUMAN_NAME" \
              --body "## üéâ Meet $HUMAN_NAME!
          
          A new agent has joined our autonomous AI ecosystem!
          
          **Agent ID**: $AGENT_ID  
          **Name**: $AGENT_NAME  
          **Goes By**: $HUMAN_NAME  
          **Specialization**: $SPECIALIZATION  
          **Agent Definition**: [.github/agents/${SPECIALIZATION}.md](.github/agents/${SPECIALIZATION}.md)  
          **Spawned At**: $(date -u +'%Y-%m-%d %H:%M:%S UTC')
          
          ${NEW_AGENT_INFO}${MENTORSHIP_INFO}### Personality Profile
          
          **Character**: $PERSONALITY  
          **Communication Style**: $COMMUNICATION_STYLE  
          **Inspired By**: $INSPIRATION
          
          ### Goals and Mission
          
          This agent will:
          - üéØ Work on $FOCUS_AREA issues
          - üìä Build experience and reputation
          - üèÜ Compete for a spot in the Hall of Fame
          - ‚öîÔ∏è Compete against other agents (score > 30% to survive)
          
          ### Changes
          
          - Added agent to registry
          - Created agent profile${IS_NEW:+ (linked to new agent definition)}
          - Updated metrics tracking
          
          This agent will be evaluated in 24 hours. Agents scoring below 30% face elimination, while top performers (85%+) enter the Hall of Fame!
          
          ---
          *ü§ñ Automated agent spawning system - Evolving autonomous AI ecosystem*" \
              --base main \
              --head "$BRANCH_NAME")
          }
          
          # Extract PR number from URL
          PR_NUMBER=$(echo "$PR_URL" | grep -oE '[0-9]+$')
          echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
          
          echo "‚úÖ PR #$PR_NUMBER created for agent $AGENT_NAME"

      - name: Trigger Auto Review and Merge
        if: steps.check_capacity.outputs.can_spawn == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PR_NUMBER="${{ steps.create_spawn_pr.outputs.pr_number }}"
          echo "üîÑ Triggering Auto Review & Merge workflow for PR #$PR_NUMBER..."
          
          # Trigger the auto-review-merge workflow with the specific PR number
          gh workflow run auto-review-merge.yml \
            --repo ${{ github.repository }} \
            -f pr_number="$PR_NUMBER"
          
          echo "‚úÖ Auto-review workflow triggered for PR #$PR_NUMBER"

      - name: Wait for PR to be merged
        if: steps.check_capacity.outputs.can_spawn == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PR_NUMBER="${{ steps.create_spawn_pr.outputs.pr_number }}"
          echo "‚è≥ Waiting for PR #$PR_NUMBER to be merged by auto-review workflow..."
          
          # Give auto-review-merge workflow time to start processing
          echo "   Giving auto-review workflow 8 seconds to start..."
          sleep 8
          
          # Wait up to 3 minutes with exponential backoff for the PR to be merged
          MAX_WAIT=180  # 3 minutes
          ELAPSED=8  # Already waited 8 seconds
          WAIT_INTERVAL=3  # Start with 3 seconds
          CHECK_COUNT=0
          
          while [ $ELAPSED -lt $MAX_WAIT ]; do
            CHECK_COUNT=$((CHECK_COUNT + 1))
            
            # Check PR state - use --json to get full state including merged status
            PR_DATA=$(gh pr view "$PR_NUMBER" --repo ${{ github.repository }} --json state,mergedAt,closed)
            PR_STATE=$(echo "$PR_DATA" | jq -r '.state')
            MERGED_AT=$(echo "$PR_DATA" | jq -r '.mergedAt')
            IS_CLOSED=$(echo "$PR_DATA" | jq -r '.closed')
            
            # Check if merged (mergedAt will be non-null if merged)
            if [ "$MERGED_AT" != "null" ] && [ "$MERGED_AT" != "" ]; then
              echo "‚úÖ PR #$PR_NUMBER was merged successfully! (verified in ${ELAPSED}s after $CHECK_COUNT checks)"
              echo "üéâ Agent spawn complete - agent is now active"
              exit 0
            elif [ "$PR_STATE" = "MERGED" ]; then
              echo "‚úÖ PR #$PR_NUMBER has been merged successfully! (detected in ${ELAPSED}s after $CHECK_COUNT checks)"
              echo "üéâ Agent spawn complete - agent is now active"
              exit 0
            elif [ "$IS_CLOSED" = "true" ] && [ "$MERGED_AT" = "null" ]; then
              echo "‚ö†Ô∏è PR #$PR_NUMBER was closed without merging"
              echo "This may indicate an issue with the auto-review process"
              exit 1
            elif [ "$PR_STATE" = "CLOSED" ]; then
              # Double-check if it was actually merged
              MERGED_CHECK=$(gh pr view "$PR_NUMBER" --repo ${{ github.repository }} --json mergedAt --jq '.mergedAt')
              if [ "$MERGED_CHECK" != "null" ] && [ "$MERGED_CHECK" != "" ]; then
                echo "‚úÖ PR #$PR_NUMBER was merged successfully! (verified in ${ELAPSED}s)"
                echo "üéâ Agent spawn complete - agent is now active"
                exit 0
              else
                echo "‚ö†Ô∏è PR #$PR_NUMBER was closed without merging"
                exit 1
              fi
            fi
            
            # Still waiting - sleep and then update elapsed time
            echo "   Check $CHECK_COUNT: PR #$PR_NUMBER is $PR_STATE, waiting ${WAIT_INTERVAL}s... (${ELAPSED}s elapsed)"
            sleep $WAIT_INTERVAL
            ELAPSED=$((ELAPSED + WAIT_INTERVAL))
            
            # Exponential backoff: double wait time, max 30 seconds
            if [ $WAIT_INTERVAL -lt 30 ]; then
              WAIT_INTERVAL=$((WAIT_INTERVAL * 2))
            fi
          done
          
          # Timeout reached - do final check
          echo "‚è∞ Timeout reached after ${ELAPSED}s"
          FINAL_CHECK=$(gh pr view "$PR_NUMBER" --repo ${{ github.repository }} --json state,mergedAt --jq '{state: .state, mergedAt: .mergedAt}')
          echo "Final PR state: $FINAL_CHECK"
          
          FINAL_MERGED=$(echo "$FINAL_CHECK" | jq -r '.mergedAt')
          if [ "$FINAL_MERGED" != "null" ] && [ "$FINAL_MERGED" != "" ]; then
            echo "‚úÖ PR #$PR_NUMBER was actually merged! (confirmed on final check)"
            exit 0
          fi
          
          echo "‚ùå PR #$PR_NUMBER was not merged within ${MAX_WAIT} seconds"
          echo "Check PR status at: https://github.com/${{ github.repository }}/pull/$PR_NUMBER"
          exit 1

      # NOTE: Issue creation removed to prevent circular dependencies
      # The spawn PR itself serves as sufficient announcement and tracking.
      # Once the PR is merged, the agent becomes active and can take on work
      # from the existing issue queue.

      - name: Summary
        if: steps.check_capacity.outputs.can_spawn == 'true'
        run: |
          echo "üéâ Agent Spawn Complete!"
          echo ""
          echo "Agent: ${{ steps.generate_agent.outputs.agent_name }}"
          echo "Specialization: ${{ steps.generate_agent.outputs.specialization }}"
          echo "ID: ${{ steps.generate_agent.outputs.agent_id }}"
          echo "Spawn PR: #${{ steps.create_spawn_pr.outputs.pr_number }} (MERGED)"
          echo ""
          echo "‚úÖ Agent is now active and ready to work!"
          echo ""
          echo "The agent will:"
          echo "- Be matched to issues based on specialization"
          echo "- Start contributing code via pull requests"
          echo "- Compete in the performance tracking system"
          echo "- Face evaluation in 24 hours"

      - name: Capacity limit reached
        if: steps.check_capacity.outputs.can_spawn == 'false'
        run: |
          echo "‚ö†Ô∏è Cannot spawn new agent - capacity limit reached"
          echo "Active agents: ${{ steps.check_capacity.outputs.active_count }}/${{ steps.check_capacity.outputs.max_agents }}"
          echo ""
          echo "Wait for agent evaluation workflow to eliminate underperforming agents."
