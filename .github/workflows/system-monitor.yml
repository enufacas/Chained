name: "System: Monitor"

on:
  schedule:
    # Run every 6 hours for timeline updates
    # Run every 12 hours for progress tracking and workflow monitoring
    - cron: '0 */6 * * *'
    # Run every 3 hours for merge conflict resolution, agent health, and pages health
    - cron: '0 */3 * * *'
  issues:
    types: [opened, closed, labeled]
  pull_request:
    types: [opened, closed, merged]
  workflow_dispatch:
    inputs:
      skip_timeline:
        description: 'Skip timeline update'
        required: false
        type: boolean
        default: false
      skip_progress:
        description: 'Skip progress tracking'
        required: false
        type: boolean
        default: false
      skip_workflow_monitor:
        description: 'Skip workflow monitoring'
        required: false
        type: boolean
        default: false
      skip_merge_conflicts:
        description: 'Skip merge conflict resolution'
        required: false
        type: boolean
        default: false
      skip_agent_health:
        description: 'Skip custom agent health check'
        required: false
        type: boolean
        default: false
      skip_pages_health:
        description: 'Skip GitHub Pages health check'
        required: false
        type: boolean
        default: false

permissions:
  contents: write
  issues: write
  pull-requests: write
  actions: read
  checks: read

jobs:
  timeline-update:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    # Temporarily disabled - spawning too many events, will fix later
    if: false
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Fetch repository activity
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Create timeline data directory
          mkdir -p docs/data
          
          # Fetch recent issues
          echo "Fetching recent issues..."
          gh issue list --limit 100 --json number,title,body,state,createdAt,closedAt,labels,url > docs/data/issues.json
          
          # Fetch recent pull requests
          echo "Fetching recent pull requests..."
          gh pr list --limit 100 --state all --json number,title,body,state,createdAt,closedAt,mergedAt,url,author > docs/data/pulls.json
          
          # Fetch workflow runs to document automation activity
          echo "Fetching workflow runs..."
          gh run list --limit 100 --json databaseId,name,status,conclusion,createdAt,displayTitle > docs/data/workflows.json
          
          # Create activity summary
          total_issues=$(gh issue list --state all --limit 1000 --json number | jq '. | length')
          open_issues=$(gh issue list --state open --limit 1000 --json number | jq '. | length')
          closed_issues=$(gh issue list --state closed --limit 1000 --json number | jq '. | length')
          
          total_prs=$(gh pr list --state all --limit 1000 --json number | jq '. | length')
          merged_prs=$(gh pr list --state merged --limit 1000 --json number | jq '. | length')
          
          ai_generated=$(gh issue list --state all --label "ai-generated" --limit 1000 --json number | jq '. | length')
          copilot_assigned=$(gh issue list --state all --label "copilot-assigned" --limit 1000 --json number | jq '. | length')
          completed=$(gh issue list --state all --label "completed" --limit 1000 --json number | jq '. | length')
          in_progress=$(gh issue list --state open --label "in-progress" --limit 1000 --json number | jq '. | length')
          
          # Calculate metrics
          if [ ${ai_generated} -gt 0 ]; then
            completion_rate=$(awk "BEGIN {printf \"%.1f\", (${completed}/${ai_generated})*100}")
          else
            completion_rate="0.0"
          fi
          
          if [ ${total_prs} -gt 0 ]; then
            merge_rate=$(awk "BEGIN {printf \"%.1f\", (${merged_prs}/${total_prs})*100}")
          else
            merge_rate="0.0"
          fi
          
          cat > docs/data/stats.json << EOF
          {
            "total_issues": ${total_issues},
            "open_issues": ${open_issues},
            "closed_issues": ${closed_issues},
            "total_prs": ${total_prs},
            "merged_prs": ${merged_prs},
            "ai_generated": ${ai_generated},
            "copilot_assigned": ${copilot_assigned},
            "completed": ${completed},
            "in_progress": ${in_progress},
            "completion_rate": ${completion_rate},
            "merge_rate": ${merge_rate},
            "last_updated": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
          }
          EOF
          
          # Create automation log
          cat > docs/data/automation-log.json << EOF
          {
            "last_idea_generated": "$(gh issue list --label "ai-generated" --limit 1 --json createdAt --jq '.[0].createdAt // "N/A"')",
            "last_pr_merged": "$(gh pr list --state merged --limit 1 --json mergedAt --jq '.[0].mergedAt // "N/A"')",
            "last_issue_closed": "$(gh issue list --state closed --limit 1 --json closedAt --jq '.[0].closedAt // "N/A"')",
            "autonomous_actions_today": "$(date +%s | awk '{print int($1/86400)}')",
            "system_status": "active"
          }
          EOF
          
          echo "Timeline data updated successfully with automation metrics"

      - name: Create or update PR for timeline updates
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Check if there are any changes before proceeding
          if git diff --quiet docs/data/ && ! git ls-files --others --exclude-standard docs/data/ | grep -q . 2>/dev/null; then
            echo "No changes to commit"
            exit 0
          fi
          
          # Check for existing open timeline update PRs
          existing_prs=$(gh pr list --state open --label "timeline-update" --json number,headRefName --jq '.[].number' | head -1)
          
          if [ -n "${existing_prs}" ]; then
            pr_number="${existing_prs}"
            branch_name=$(gh pr view ${pr_number} --json headRefName --jq '.headRefName')
            
            echo "Found existing timeline PR #${pr_number} on branch ${branch_name}"
            
            # Check last update time of the PR to avoid too frequent updates
            last_update=$(gh pr view ${pr_number} --json updatedAt --jq '.updatedAt')
            last_update_seconds=$(date -d "${last_update}" +%s 2>/dev/null || date -j -f "%Y-%m-%dT%H:%M:%SZ" "${last_update}" +%s 2>/dev/null || echo 0)
            current_seconds=$(date +%s)
            seconds_since_update=$((current_seconds - last_update_seconds))
            
            # Skip if updated less than 5 minutes ago (300 seconds)
            if [ ${seconds_since_update} -lt 300 ]; then
              echo "‚è≠Ô∏è  Skipping update - PR was updated ${seconds_since_update} seconds ago (< 5 minutes)"
              exit 0
            fi
            
            # Update the existing branch by resetting it to main (avoids merge conflicts)
            # First, save the current changes
            git add docs/data/
            git stash push -m "timeline-update-$(date +%s)"
            
            # Fetch latest main and reset branch to it
            git fetch origin main
            git fetch origin "${branch_name}"
            git checkout "${branch_name}"
            git reset --hard origin/main
            
            # Apply the stashed changes
            git stash pop || {
              echo "‚ö†Ô∏è  Conflict while applying changes, using --theirs strategy"
              git checkout --theirs docs/data/
              git add docs/data/
              git stash drop
            }
            
            git add docs/data/
            git commit -m "üìä Update timeline data - $(date -u +'%Y-%m-%d %H:%M:%S UTC')" || {
              echo "No new changes to commit to existing PR"
              exit 0
            }
            git push --force-with-lease origin "${branch_name}"
            
            echo "‚úÖ Updated existing PR #${pr_number}"
          else
            # No existing PR, create a new one
            branch_name="timeline/update-$(date +%Y%m%d-%H%M%S)"
            git checkout -b "${branch_name}"
            
            git add docs/data/
            git commit -m "üìä Update timeline data - $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
            git push origin "${branch_name}"
            
            # Create PR with timeline-update label for tracking
            gh pr create \
              --title "üìä Timeline Update - $(date -u +'%Y-%m-%d %H:%M:%S UTC')" \
              --body "## Automated Timeline Data Update
            
            **Date:** $(date -u +'%Y-%m-%d %H:%M:%S UTC')
            
            ### Summary
            This PR updates the timeline data with the latest repository activity metrics.
            
            ### Changes
            - Updated issues and pull request data
            - Refreshed workflow run statistics
            - Updated automation metrics and completion rates
            - Regenerated activity summary
            
            ### Data Updated
            - \`docs/data/issues.json\` - Recent issues
            - \`docs/data/pulls.json\` - Recent pull requests
            - \`docs/data/workflows.json\` - Workflow runs
            - \`docs/data/stats.json\` - Repository statistics
            - \`docs/data/automation-log.json\` - Automation activity
            
            ---
            *This PR was automatically created by the System Monitor workflow and will be auto-merged.*" \
              --label "automated,copilot" \
              --base main \
              --head "${branch_name}"
            
            echo "‚úÖ PR created successfully for timeline update"
          fi

  progress-tracking:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    # Run on schedule or when manually triggered (unless skipped)
    if: |
      github.event_name == 'schedule' ||
      (github.event_name == 'workflow_dispatch' && inputs.skip_progress != true)
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Analyze repository progress
        id: analyze
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Get issue statistics
          total_issues=$(gh issue list --state all --limit 1000 --json number | jq '. | length')
          open_issues=$(gh issue list --state open --limit 1000 --json number | jq '. | length')
          closed_issues=$(gh issue list --state closed --limit 1000 --json number | jq '. | length')
          
          # Get AI-generated issue statistics
          ai_issues=$(gh issue list --state all --label "ai-generated" --limit 1000 --json number | jq '. | length')
          ai_completed=$(gh issue list --state closed --label "ai-generated" --limit 1000 --json number | jq '. | length')
          
          # Get Copilot-assigned statistics
          copilot_issues=$(gh issue list --state all --label "copilot-assigned" --limit 1000 --json number | jq '. | length')
          
          # Calculate completion rate
          if [ ${ai_issues} -gt 0 ]; then
            completion_rate=$(awk "BEGIN {printf \"%.1f\", (${ai_completed}/${ai_issues})*100}")
          else
            completion_rate="0.0"
          fi
          
          echo "total_issues=${total_issues}" >> $GITHUB_OUTPUT
          echo "open_issues=${open_issues}" >> $GITHUB_OUTPUT
          echo "closed_issues=${closed_issues}" >> $GITHUB_OUTPUT
          echo "ai_issues=${ai_issues}" >> $GITHUB_OUTPUT
          echo "ai_completed=${ai_completed}" >> $GITHUB_OUTPUT
          echo "copilot_issues=${copilot_issues}" >> $GITHUB_OUTPUT
          echo "completion_rate=${completion_rate}" >> $GITHUB_OUTPUT

      - name: Create progress report
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Create a progress report
          report="## üìä Progress Report - $(date -u +'%Y-%m-%d %H:%M:%S UTC')

          ### Overall Statistics
          - **Total Issues:** ${{ steps.analyze.outputs.total_issues }}
          - **Open Issues:** ${{ steps.analyze.outputs.open_issues }}
          - **Closed Issues:** ${{ steps.analyze.outputs.closed_issues }}

          ### AI Motion Machine Statistics
          - **AI-Generated Ideas:** ${{ steps.analyze.outputs.ai_issues }}
          - **Completed AI Tasks:** ${{ steps.analyze.outputs.ai_completed }}
          - **Copilot Assignments:** ${{ steps.analyze.outputs.copilot_issues }}
          - **Completion Rate:** ${{ steps.analyze.outputs.completion_rate }}%

          ### System Status
          - ‚úÖ Idea Generator: Active
          - ‚úÖ Copilot Auto-Assign: Active
          - ‚úÖ System Monitor: Active

          ---

          *This report was automatically generated by the System Monitor workflow.*"
          
          # Try to find existing progress tracking issue
          tracking_issue=$(gh issue list --label "progress-report" --state open --limit 1 --json number | jq -r '.[0].number // empty')
          
          if [ -n "${tracking_issue}" ]; then
            echo "Adding progress report to issue #${tracking_issue}"
            echo "${report}" | gh issue comment ${tracking_issue} --body-file -
          else
            echo "No tracking issue found. Progress logged to workflow output."
            echo "${report}"
          fi

  workflow-monitoring:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    # Run on schedule or when manually triggered (unless skipped)
    if: |
      github.event_name == 'schedule' ||
      (github.event_name == 'workflow_dispatch' && inputs.skip_workflow_monitor != true)
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Monitor workflow health
        id: monitor
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "üîç Monitoring workflow health..."
          echo ""
          
          # Get workflow runs from the last 100
          runs_json=$(gh run list --limit 100 --json databaseId,name,status,conclusion,createdAt,displayTitle)
          
          # Count all runs by conclusion type
          total_runs=$(echo "$runs_json" | jq '. | length')
          failed_runs=$(echo "$runs_json" | jq '[.[] | select(.conclusion == "failure")] | length')
          cancelled_runs=$(echo "$runs_json" | jq '[.[] | select(.conclusion == "cancelled")] | length')
          success_runs=$(echo "$runs_json" | jq '[.[] | select(.conclusion == "success")] | length')
          skipped_runs=$(echo "$runs_json" | jq '[.[] | select(.conclusion == "skipped")] | length')
          action_required_runs=$(echo "$runs_json" | jq '[.[] | select(.conclusion == "action_required")] | length')
          
          # Calculate completed runs (success + failure only, excluding skipped, cancelled, action_required)
          completed_runs=$((success_runs + failed_runs))
          
          echo "Total runs (last 100): $total_runs"
          echo "Completed runs (success + failure): $completed_runs"
          echo "  - Successful: $success_runs"
          echo "  - Failed: $failed_runs"
          echo "Non-completed runs: $((total_runs - completed_runs))"
          echo "  - Cancelled: $cancelled_runs"
          echo "  - Skipped: $skipped_runs"
          echo "  - Action Required: $action_required_runs"
          echo ""
          
          # Calculate failure rate based on completed runs only
          if [ "$completed_runs" -gt 0 ]; then
            failure_rate=$(awk "BEGIN {printf \"%.1f\", ($failed_runs/$completed_runs)*100}")
          else
            failure_rate="0.0"
          fi
          
          echo "Failure rate (of completed runs): ${failure_rate}%"
          echo ""
          
          # Set outputs
          echo "failure_rate=${failure_rate}" >> $GITHUB_OUTPUT
          echo "failed_runs=${failed_runs}" >> $GITHUB_OUTPUT
          echo "total_runs=${total_runs}" >> $GITHUB_OUTPUT
          echo "completed_runs=${completed_runs}" >> $GITHUB_OUTPUT
          
          # Determine if critical (more than 10 failures OR failure rate > 20%)
          failure_rate_int=${failure_rate%.*}
          if [ "$failed_runs" -gt 10 ] || [ "$failure_rate_int" -gt 20 ]; then
            echo "has_critical_failures=true" >> $GITHUB_OUTPUT
          else
            echo "has_critical_failures=false" >> $GITHUB_OUTPUT
          fi

      - name: Create monitoring issue if needed
        if: steps.monitor.outputs.has_critical_failures == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Creating monitoring alert issue..."
          
          # Check if there's already an open monitoring issue
          existing_issue=$(gh issue list --label "workflow-monitor" --state open --limit 1 --json number --jq '.[0].number' || echo "")
          
          if [ -n "$existing_issue" ]; then
            echo "Updating existing monitoring issue #${existing_issue}"
            
            gh issue comment "${existing_issue}" --body "## üîÑ Updated Workflow Health Check
            
            **Timestamp:** $(date -u +'%Y-%m-%d %H:%M:%S UTC')
            
            ### Current Status
            - **Total Workflow Runs:** ${{ steps.monitor.outputs.total_runs }}
            - **Completed Runs:** ${{ steps.monitor.outputs.completed_runs }} (success + failure)
            - **Failed Runs:** ${{ steps.monitor.outputs.failed_runs }}
            - **Failure Rate:** ${{ steps.monitor.outputs.failure_rate }}% (of completed runs)
            
            ---
            *Automated update from System Monitor*"
          else
            echo "Creating new monitoring issue"
            
            gh issue create \
              --title "‚ö†Ô∏è Workflow Health Alert - $(date -u +%Y-%m-%d)" \
              --body "## Workflow Health Monitoring Alert
            
            The workflow monitor has detected issues that require attention.
            
            **Detection Time:** $(date -u +'%Y-%m-%d %H:%M:%S UTC')
            
            ### Health Summary
            - **Total Workflow Runs:** ${{ steps.monitor.outputs.total_runs }}
            - **Completed Runs:** ${{ steps.monitor.outputs.completed_runs }} (success + failure)
            - **Failed Runs:** ${{ steps.monitor.outputs.failed_runs }}
            - **Failure Rate:** ${{ steps.monitor.outputs.failure_rate }}% (of completed runs)
            
            ### Recommended Actions
            1. Review failed workflow runs in the Actions tab
            2. Check for permission or authentication issues
            3. Verify workflow configurations
            4. Review recent changes to workflows
            
            ### Monitoring
            This issue will be automatically updated with health checks every 12 hours.
            Close this issue once all problems are resolved.
            
            ---
            *This issue was automatically created by the System Monitor workflow.*" \
              --label "workflow-monitor,automated"
          fi

      - name: Generate health report
        run: |
          echo "================================================================"
          echo "Workflow Health Report"
          echo "================================================================"
          echo ""
          echo "Timestamp: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          echo ""
          echo "Summary:"
          echo "  Total Runs: ${{ steps.monitor.outputs.total_runs }}"
          echo "  Completed Runs: ${{ steps.monitor.outputs.completed_runs }}"
          echo "  Failed: ${{ steps.monitor.outputs.failed_runs }}"
          echo "  Failure Rate: ${{ steps.monitor.outputs.failure_rate }}% (of completed runs)"
          echo ""
          
          if [ "${{ steps.monitor.outputs.has_critical_failures }}" = "true" ]; then
            echo "Status: ‚ö†Ô∏è  ATTENTION NEEDED"
            echo "High failure rate detected"
          else
            echo "Status: ‚úÖ HEALTHY"
            echo "All workflows operating normally"
          fi
          echo ""
          echo "================================================================"

  merge-conflict-resolution:
    runs-on: ubuntu-latest
    timeout-minutes: 20
    # Run on schedule or when manually triggered (unless skipped)
    if: |
      github.event_name == 'schedule' ||
      (github.event_name == 'workflow_dispatch' && inputs.skip_merge_conflicts != true)
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Sweep open PRs for merge conflicts
        id: check_conflicts
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "üîç Sweeping open PRs for merge conflicts..."
          echo ""
          
          # Get all open PRs
          pr_list=$(gh pr list --state open --json number,title,mergeable,mergeStateStatus --jq '.[] | "\(.number)|\(.title)|\(.mergeable)|\(.mergeStateStatus)"')
          
          if [ -z "${pr_list}" ]; then
            echo "‚ÑπÔ∏è No open PRs found"
            echo "has_conflicts=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          conflict_count=0
          conflict_prs=""
          
          echo "Checking PRs for merge conflicts..."
          while IFS='|' read -r pr_number pr_title mergeable merge_state; do
            echo "Checking PR #${pr_number}: ${pr_title}"
            echo "  Mergeable: ${mergeable}, Merge State: ${merge_state}"
            
            # Check if PR has conflicts (handle empty values)
            if [ "${mergeable}" = "CONFLICTING" ] || [ "${merge_state}" = "DIRTY" ]; then
              echo "  ‚ö†Ô∏è PR #${pr_number} has merge conflicts"
              conflict_count=$((conflict_count + 1))
              conflict_prs="${conflict_prs} ${pr_number}"
            elif [ -z "${mergeable}" ] || [ -z "${merge_state}" ]; then
              echo "  ‚ö†Ô∏è PR #${pr_number} has unknown merge status, skipping"
            else
              echo "  ‚úÖ PR #${pr_number} is clean"
            fi
          done <<< "${pr_list}"
          
          echo ""
          echo "Found ${conflict_count} PR(s) with merge conflicts"
          
          if [ ${conflict_count} -gt 0 ]; then
            echo "has_conflicts=true" >> $GITHUB_OUTPUT
            echo "conflict_prs=${conflict_prs}" >> $GITHUB_OUTPUT
            echo "conflict_count=${conflict_count}" >> $GITHUB_OUTPUT
          else
            echo "has_conflicts=false" >> $GITHUB_OUTPUT
          fi

      - name: Resolve merge conflicts intelligently
        if: steps.check_conflicts.outputs.has_conflicts == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "üîß Attempting to resolve merge conflicts..."
          echo ""
          
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          for pr_num in ${{ steps.check_conflicts.outputs.conflict_prs }}; do
            echo "Processing PR #${pr_num}"
            
            # Get PR details
            pr_data=$(gh pr view ${pr_num} --json headRefName,baseRefName,author,labels)
            head_branch=$(echo "${pr_data}" | jq -r '.headRefName')
            base_branch=$(echo "${pr_data}" | jq -r '.baseRefName')
            author=$(echo "${pr_data}" | jq -r '.author.login')
            has_copilot_label=$(echo "${pr_data}" | jq -r '.labels[].name' 2>/dev/null | grep -c "copilot" 2>/dev/null || echo "0")
            
            # Only auto-resolve for trusted sources
            is_trusted=0
            if echo "${author}" | grep -qiE "^(github-actions\[bot\]|app/github-actions|dependabot\[bot\]|app/dependabot|app/copilot|copilot)" 2>/dev/null; then
              is_trusted=1
            elif [ "${author}" = "${{ github.repository_owner }}" ] && [ "${has_copilot_label}" -gt 0 ]; then
              is_trusted=1
            fi
            
            if [ ${is_trusted} -eq 0 ]; then
              echo "‚ö†Ô∏è PR #${pr_num} is not from a trusted source, skipping auto-resolution"
              gh pr comment ${pr_num} --body "‚ö†Ô∏è **Merge Conflicts Detected**
              
              This PR has merge conflicts that need to be resolved manually.
              
              **Action required:** Please resolve the conflicts and update the PR.
              
              ---
              *Detected by System Monitor - Merge Conflict Resolution*" || true
              continue
            fi
            
            echo "‚úÖ PR #${pr_num} is from trusted source (${author}), attempting resolution"
            
            # Fetch and checkout the PR branch
            git fetch origin "${head_branch}" || {
              echo "‚ùå Failed to fetch branch ${head_branch}"
              continue
            }
            
            git checkout "${head_branch}" || {
              echo "‚ùå Failed to checkout branch ${head_branch}"
              continue
            }
            
            # Fetch latest base branch
            git fetch origin "${base_branch}"
            
            # Attempt to merge base into head with strategy
            # Try ours strategy first (prefer PR changes for automated PRs)
            if git merge "origin/${base_branch}" -X ours --no-edit; then
              echo "‚úÖ Merged ${base_branch} into ${head_branch} using 'ours' strategy"
              
              # Push the resolved conflicts
              if git push origin "${head_branch}"; then
                echo "‚úÖ Pushed conflict resolution for PR #${pr_num}"
                
                gh pr comment ${pr_num} --body "‚úÖ **Merge Conflicts Resolved**
                
                The merge conflicts in this PR have been automatically resolved.
                
                **Resolution strategy:** Used 'ours' strategy (preferred PR changes)
                **Base branch:** \`${base_branch}\`
                **Updated branch:** \`${head_branch}\`
                
                The PR should now be ready for review and merge.
                
                **Timestamp:** $(date -u +'%Y-%m-%d %H:%M:%S UTC')
                
                ---
                *Automatically resolved by System Monitor - Merge Conflict Resolution*" || true
              else
                echo "‚ùå Failed to push conflict resolution"
              fi
            else
              # Merge failed, abort and try alternative strategy
              git merge --abort
              
              echo "‚ö†Ô∏è 'ours' strategy failed, trying 'theirs' strategy"
              
              if git merge "origin/${base_branch}" -X theirs --no-edit; then
                echo "‚úÖ Merged ${base_branch} into ${head_branch} using 'theirs' strategy"
                
                if git push origin "${head_branch}"; then
                  echo "‚úÖ Pushed conflict resolution for PR #${pr_num}"
                  
                  gh pr comment ${pr_num} --body "‚úÖ **Merge Conflicts Resolved**
                  
                  The merge conflicts in this PR have been automatically resolved.
                  
                  **Resolution strategy:** Used 'theirs' strategy (preferred base branch changes)
                  **Base branch:** \`${base_branch}\`
                  **Updated branch:** \`${head_branch}\`
                  
                  ‚ö†Ô∏è Note: This strategy preferred changes from the base branch. Please verify the changes.
                  
                  **Timestamp:** $(date -u +'%Y-%m-%d %H:%M:%S UTC')
                  
                  ---
                  *Automatically resolved by System Monitor - Merge Conflict Resolution*" || true
                else
                  echo "‚ùå Failed to push conflict resolution"
                fi
              else
                # Both strategies failed
                git merge --abort
                
                echo "‚ùå Automatic resolution failed for PR #${pr_num}"
                
                gh pr comment ${pr_num} --body "‚ö†Ô∏è **Automatic Conflict Resolution Failed**
                
                This PR has complex merge conflicts that could not be automatically resolved.
                
                **Action required:** Manual resolution is needed.
                
                Please:
                1. Pull the latest changes from \`${base_branch}\`
                2. Resolve conflicts manually
                3. Push the updated branch
                
                **Timestamp:** $(date -u +'%Y-%m-%d %H:%M:%S UTC')
                
                ---
                *Attempted by System Monitor - Merge Conflict Resolution*" || true
              fi
            fi
            
            # Return to main branch
            git checkout main 2>/dev/null || git checkout master 2>/dev/null || true
          done

      - name: Report merge conflict resolution
        if: steps.check_conflicts.outputs.has_conflicts == 'true'
        run: |
          echo "================================================================"
          echo "Merge Conflict Resolution Report"
          echo "================================================================"
          echo ""
          echo "Timestamp: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          echo "PRs with conflicts: ${{ steps.check_conflicts.outputs.conflict_count }}"
          echo "PR numbers: ${{ steps.check_conflicts.outputs.conflict_prs }}"
          echo ""
          echo "Resolution attempts completed. Check individual PR comments for details."
          echo "================================================================"

  agent-health-check:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    # Run on schedule or when manually triggered (unless skipped)
    if: |
      github.event_name == 'schedule' ||
      (github.event_name == 'workflow_dispatch' && inputs.skip_agent_health != true)
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.x'

      - name: Check agent system health
        id: agent_check
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "üîç Checking custom agent system health..."
          echo ""
          
          # Check 1: Verify agent spawner workflow exists and is enabled
          echo "Check 1: Agent Spawner Workflow"
          if [ -f ".github/workflows/agent-spawner.yml" ]; then
            echo "‚úÖ Agent spawner workflow exists"
            spawner_healthy=1
          else
            echo "‚ùå Agent spawner workflow missing"
            spawner_healthy=0
          fi
          
          # Check 2: Verify agent data files exist
          echo ""
          echo "Check 2: Agent Data Files"
          agent_files_healthy=1
          if [ -d "docs/data/agents" ]; then
            agent_count=$(find docs/data/agents -name "*.json" -type f 2>/dev/null | wc -l)
            echo "‚úÖ Agent data directory exists with ${agent_count} agent file(s)"
            if [ ${agent_count} -eq 0 ]; then
              echo "‚ö†Ô∏è No agent data files found"
              agent_files_healthy=0
            fi
          else
            echo "‚ùå Agent data directory missing"
            agent_files_healthy=0
          fi
          
          # Check 3: Verify recent agent activity
          echo ""
          echo "Check 3: Recent Agent Activity"
          recent_agent_issues=$(gh issue list --label "agent-created" --limit 10 --json number,createdAt --jq 'length')
          if [ ${recent_agent_issues} -gt 0 ]; then
            echo "‚úÖ Found ${recent_agent_issues} recent agent-created issues"
            agent_activity_healthy=1
          else
            echo "‚ö†Ô∏è No recent agent-created issues found"
            agent_activity_healthy=0
          fi
          
          # Check 4: Verify agent assignment is working
          echo ""
          echo "Check 4: Agent Assignment"
          assigned_issues=$(gh issue list --label "copilot-assigned" --state open --limit 10 --json number --jq 'length')
          if [ ${assigned_issues} -gt 0 ]; then
            echo "‚úÖ Found ${assigned_issues} assigned issue(s)"
            assignment_healthy=1
          else
            echo "‚ö†Ô∏è No open assigned issues found"
            assignment_healthy=0
          fi
          
          # Check 5: Verify agent scoring/evaluation workflow
          echo ""
          echo "Check 5: Agent Evaluation"
          if [ -f ".github/workflows/agent-evaluator.yml" ]; then
            echo "‚úÖ Agent evaluator workflow exists"
            evaluator_healthy=1
          else
            echo "‚ö†Ô∏è Agent evaluator workflow missing"
            evaluator_healthy=0
          fi
          
          # Calculate overall health score
          total_checks=5
          passed_checks=$((spawner_healthy + agent_files_healthy + agent_activity_healthy + assignment_healthy + evaluator_healthy))
          health_percentage=$((passed_checks * 100 / total_checks))
          
          echo ""
          echo "================================================================"
          echo "Agent System Health: ${passed_checks}/${total_checks} checks passed (${health_percentage}%)"
          echo "================================================================"
          
          # Set outputs
          echo "health_percentage=${health_percentage}" >> $GITHUB_OUTPUT
          echo "passed_checks=${passed_checks}" >> $GITHUB_OUTPUT
          echo "total_checks=${total_checks}" >> $GITHUB_OUTPUT
          
          if [ ${health_percentage} -lt 60 ]; then
            echo "health_status=critical" >> $GITHUB_OUTPUT
          elif [ ${health_percentage} -lt 80 ]; then
            echo "health_status=warning" >> $GITHUB_OUTPUT
          else
            echo "health_status=healthy" >> $GITHUB_OUTPUT
          fi

      - name: Perform agent system diagnostics
        if: steps.agent_check.outputs.health_status != 'healthy'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "üîß Performing agent system diagnostics..."
          echo ""
          
          # Check if agent spawner has recent runs
          echo "Checking agent spawner workflow runs..."
          spawner_runs=$(gh run list --workflow=agent-spawner.yml --limit 10 --json conclusion,createdAt --jq 'length')
          
          if [ ${spawner_runs} -eq 0 ]; then
            echo "‚ö†Ô∏è Agent spawner has no recent runs"
            echo "Recommendation: Trigger agent spawner workflow manually"
          else
            echo "Agent spawner runs found: ${spawner_runs}"
            
            # Check for failures
            failed_runs=$(gh run list --workflow=agent-spawner.yml --limit 10 --json conclusion --jq '[.[] | select(.conclusion == "failure")] | length')
            if [ ${failed_runs} -gt 0 ]; then
              echo "‚ö†Ô∏è Found ${failed_runs} failed spawner run(s)"
              echo "Recommendation: Review agent-spawner.yml workflow logs"
            fi
          fi
          
          # Check agent assignment workflow
          echo ""
          echo "Checking agent assignment workflow..."
          if [ -f ".github/workflows/copilot-graphql-assign.yml" ]; then
            assignment_runs=$(gh run list --workflow=copilot-graphql-assign.yml --limit 5 --json conclusion --jq 'length')
            echo "Assignment workflow runs: ${assignment_runs}"
          fi
          
          # Provide recommendations
          echo ""
          echo "Recommendations for improving agent system health:"
          if [ ${{ steps.agent_check.outputs.health_percentage }} -lt 60 ]; then
            echo "1. Verify all agent workflows are enabled"
            echo "2. Check workflow permissions and secrets"
            echo "3. Review recent workflow failures in Actions tab"
            echo "4. Consider re-initializing agent system"
          else
            echo "1. Monitor agent activity over next few cycles"
            echo "2. Verify agent scoring is working correctly"
            echo "3. Check for any workflow permission issues"
          fi

      - name: Create or update agent health issue
        if: steps.agent_check.outputs.health_status == 'critical'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Check if there's already an open agent health issue
          existing_issue=$(gh issue list --label "agent-health" --state open --limit 1 --json number --jq '.[0].number // empty')
          
          health_report="## ü§ñ Agent System Health Check
          
          **Timestamp:** $(date -u +'%Y-%m-%d %H:%M:%S UTC')
          **Health Status:** ‚ö†Ô∏è Critical (${{ steps.agent_check.outputs.passed_checks }}/${{ steps.agent_check.outputs.total_checks }} checks passed)
          
          ### Health Checks
          
          The agent system health check has identified issues that need attention.
          
          **Health Score:** ${{ steps.agent_check.outputs.health_percentage }}%
          
          ### Recommended Actions
          
          1. Review agent spawner workflow status
          2. Check agent data files in \`docs/data/agents/\`
          3. Verify agent assignment is working
          4. Review recent workflow runs in Actions tab
          5. Check for any permission or configuration issues
          
          ### Next Steps
          
          This health check runs every 3 hours. The issue will be automatically updated with the latest status.
          Close this issue once all problems are resolved and health is above 80%.
          
          ---
          *Automated health check by System Monitor*"
          
          if [ -n "${existing_issue}" ]; then
            echo "Updating existing agent health issue #${existing_issue}"
            echo "${health_report}" | gh issue comment "${existing_issue}" --body-file -
          else
            echo "Creating new agent health issue"
            echo "${health_report}" | gh issue create \
              --title "‚ö†Ô∏è Agent System Health Check - $(date -u +%Y-%m-%d)" \
              --body-file - \
              --label "agent-health,automated,system-monitor"
          fi

      - name: Report agent health status
        run: |
          echo "================================================================"
          echo "Agent System Health Check Report"
          echo "================================================================"
          echo ""
          echo "Timestamp: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          echo "Health Status: ${{ steps.agent_check.outputs.health_status }}"
          echo "Checks Passed: ${{ steps.agent_check.outputs.passed_checks }}/${{ steps.agent_check.outputs.total_checks }}"
          echo "Health Score: ${{ steps.agent_check.outputs.health_percentage }}%"
          echo ""
          
          if [ "${{ steps.agent_check.outputs.health_status }}" = "healthy" ]; then
            echo "Status: ‚úÖ HEALTHY"
            echo "Agent system is operating normally"
          elif [ "${{ steps.agent_check.outputs.health_status }}" = "warning" ]; then
            echo "Status: ‚ö†Ô∏è  WARNING"
            echo "Agent system needs attention"
          else
            echo "Status: ‚ùå CRITICAL"
            echo "Agent system requires immediate attention"
          fi
          echo ""
          echo "================================================================"

  pages-health-check:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    # Run on schedule or when manually triggered (unless skipped)
    if: |
      github.event_name == 'schedule' ||
      (github.event_name == 'workflow_dispatch' && inputs.skip_pages_health != true)
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Check GitHub Pages health
        id: pages_check
        run: |
          echo "üîç Checking GitHub Pages health..."
          echo ""
          
          issues_found=0
          
          # Check 1: Verify essential HTML files exist
          echo "Check 1: Essential HTML Files"
          html_files=(
            "docs/index.html"
            "docs/ai-knowledge-graph.html"
            "docs/ai-friends.html"
            "docs/agents.html"
          )
          
          missing_html=""
          for file in "${html_files[@]}"; do
            if [ ! -f "${file}" ]; then
              echo "‚ùå Missing: ${file}"
              missing_html="${missing_html}\n- ${file}"
              issues_found=$((issues_found + 1))
            else
              echo "‚úÖ Found: ${file}"
            fi
          done
          
          # Check 2: Verify data files exist
          echo ""
          echo "Check 2: Data Files"
          data_files=(
            "docs/data/stats.json"
            "docs/data/issues.json"
            "docs/data/pulls.json"
            "docs/data/workflows.json"
          )
          
          missing_data=""
          for file in "${data_files[@]}"; do
            if [ ! -f "${file}" ]; then
              echo "‚ùå Missing: ${file}"
              missing_data="${missing_data}\n- ${file}"
              issues_found=$((issues_found + 1))
            else
              echo "‚úÖ Found: ${file}"
            fi
          done
          
          # Check 3: Verify data freshness
          echo ""
          echo "Check 3: Data Freshness"
          if [ -f "docs/data/stats.json" ]; then
            last_updated=$(jq -r '.last_updated // empty' docs/data/stats.json)
            if [ -n "${last_updated}" ]; then
              last_updated_seconds=$(date -d "${last_updated}" +%s 2>/dev/null || date -j -f "%Y-%m-%dT%H:%M:%SZ" "${last_updated}" +%s 2>/dev/null || echo 0)
              current_seconds=$(date +%s)
              age_hours=$(( (current_seconds - last_updated_seconds) / 3600 ))
              
              if [ ${age_hours} -gt 12 ]; then
                echo "‚ö†Ô∏è Stats data is ${age_hours} hours old"
                issues_found=$((issues_found + 1))
              else
                echo "‚úÖ Stats data is fresh (${age_hours} hours old)"
              fi
            else
              echo "‚ö†Ô∏è Stats data has no last_updated field"
              issues_found=$((issues_found + 1))
            fi
          fi
          
          # Check 4: Verify GitHub Pages is accessible (basic check)
          echo ""
          echo "Check 4: GitHub Pages Deployment"
          pages_url="https://${{ github.repository_owner }}.github.io/Chained/"
          if curl -s -o /dev/null -w "%{http_code}" "${pages_url}" 2>/dev/null | grep -q "200" 2>/dev/null; then
            echo "‚úÖ GitHub Pages is accessible at ${pages_url}"
          else
            echo "‚ö†Ô∏è GitHub Pages may not be accessible"
            issues_found=$((issues_found + 1))
          fi
          
          # Set outputs
          echo "issues_found=${issues_found}" >> $GITHUB_OUTPUT
          
          if [ ${issues_found} -eq 0 ]; then
            echo "pages_status=healthy" >> $GITHUB_OUTPUT
          elif [ ${issues_found} -le 2 ]; then
            echo "pages_status=warning" >> $GITHUB_OUTPUT
          else
            echo "pages_status=critical" >> $GITHUB_OUTPUT
          fi

      - name: Create or update pages health issue
        if: steps.pages_check.outputs.issues_found != '0'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Check if there's already an open pages health issue
          existing_issue=$(gh issue list --label "pages-health" --state open --limit 1 --json number --jq '.[0].number // empty')
          
          pages_report="## üìÑ GitHub Pages Health Check
          
          **Timestamp:** $(date -u +'%Y-%m-%d %H:%M:%S UTC')
          **Status:** ${{ steps.pages_check.outputs.pages_status }}
          **Issues Found:** ${{ steps.pages_check.outputs.issues_found }}
          
          ### Health Check Results
          
          The GitHub Pages health check has identified issues that need attention.
          
          ### Recommended Actions
          
          1. Verify all essential HTML files exist in \`docs/\`
          2. Check that data files in \`docs/data/\` are up to date
          3. Ensure System Monitor workflow is running regularly
          4. Verify GitHub Pages deployment is active in repository settings
          
          ### Next Steps
          
          This health check runs every 3 hours. The issue will be automatically updated with the latest status.
          Close this issue once all problems are resolved.
          
          ---
          *Automated health check by System Monitor*"
          
          if [ -n "${existing_issue}" ]; then
            echo "Updating existing pages health issue #${existing_issue}"
            echo "${pages_report}" | gh issue comment "${existing_issue}" --body-file -
          else
            echo "Creating new pages health issue"
            echo "${pages_report}" | gh issue create \
              --title "üìÑ GitHub Pages Health Check - $(date -u +%Y-%m-%d)" \
              --body-file - \
              --label "pages-health,automated,documentation"
          fi

      - name: Report pages health status
        run: |
          echo "================================================================"
          echo "GitHub Pages Health Check Report"
          echo "================================================================"
          echo ""
          echo "Timestamp: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          echo "Status: ${{ steps.pages_check.outputs.pages_status }}"
          echo "Issues Found: ${{ steps.pages_check.outputs.issues_found }}"
          echo ""
          
          if [ "${{ steps.pages_check.outputs.pages_status }}" = "healthy" ]; then
            echo "Status: ‚úÖ HEALTHY"
            echo "GitHub Pages is operating normally"
          elif [ "${{ steps.pages_check.outputs.pages_status }}" = "warning" ]; then
            echo "Status: ‚ö†Ô∏è  WARNING"
            echo "GitHub Pages needs attention"
          else
            echo "Status: ‚ùå CRITICAL"
            echo "GitHub Pages requires immediate attention"
          fi
          echo ""
          echo "================================================================"
